<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Method Syntax</title>
</head>
<body>
<h1>Method Syntax</h1>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown
in Listing 5-13.</p>
<p><Listing number="5-13" file-name="src/main.rs" caption="Defining an <code>area</code> method on the <code>Rectangle</code> struct"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-13/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code>
(implementation) block for <code>Rectangle</code>. Everything within this <code>impl</code> block
will be associated with the <code>Rectangle</code> type. Then, we move the <code>area</code> function
within the <code>impl</code> curly brackets and change the first (and in this case, only)
parameter to be <code>self</code> in the signature and everywhere within the body. In
<code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument,
we can instead use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code>
instance. The method syntax goes after an instance: We add a dot followed by
the method name, parentheses, and any arguments.</p>
<p>In the signature for <code>area</code>, we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code>.
The <code>&amp;self</code> is actually short for <code>self: &amp;Self</code>. Within an <code>impl</code> block, the
type <code>Self</code> is an alias for the type that the <code>impl</code> block is for. Methods must
have a parameter named <code>self</code> of type <code>Self</code> for their first parameter, so Rust
lets you abbreviate this with only the name <code>self</code> in the first parameter spot.
Note that we still need to use the <code>&amp;</code> in front of the <code>self</code> shorthand to
indicate that this method borrows the <code>Self</code> instance, just as we did in
<code>rectangle: &amp;Rectangle</code>. Methods can take ownership of <code>self</code>, borrow <code>self</code>
immutably, as we’ve done here, or borrow <code>self</code> mutably, just as they can any
other parameter.</p>
<p>We chose <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the function
version: We don’t want to take ownership, and we just want to read the data in
the struct, not write to it. If we wanted to change the instance that we’ve
called the method on as part of what the method does, we’d use <code>&amp;mut self</code> as
the first parameter. Having a method that takes ownership of the instance by
using just <code>self</code> as the first parameter is rare; this technique is usually
used when the method transforms <code>self</code> into something else and you want to
prevent the caller from using the original instance after the transformation.</p>
<p>The main reason for using methods instead of functions, in addition to
providing method syntax and not having to repeat the type of <code>self</code> in every
method’s signature, is for organization. We’ve put all the things we can do
with an instance of a type in one <code>impl</code> block rather than making future users
of our code search for capabilities of <code>Rectangle</code> in various places in the
library we provide.</p>
<p>Note that we can choose to give a method the same name as one of the struct’s
fields. For example, we can define a method on <code>Rectangle</code> that is also named
<code>width</code>:</p>
<p><Listing file-name="src/main.rs"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-06-method-field-interaction/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>Here, we’re choosing to make the <code>width</code> method return <code>true</code> if the value in
the instance’s <code>width</code> field is greater than <code>0</code> and <code>false</code> if the value is
<code>0</code>: We can use a field within a method of the same name for any purpose. In
<code>main</code>, when we follow <code>rect1.width</code> with parentheses, Rust knows we mean the
method <code>width</code>. When we don’t use parentheses, Rust knows we mean the field
<code>width</code>.</p>
<p>Often, but not always, when we give a method the same name as a field we want
it to only return the value in the field and do nothing else. Methods like this
are called <em>getters</em>, and Rust does not implement them automatically for struct
fields as some other languages do. Getters are useful because you can make the
field private but the method public and thus enable read-only access to that
field as part of the type’s public API. We will discuss what public and private
are and how to designate a field or method as public or private in [Chapter
7][public]<!-- ignore -->.</p>
<blockquote>
<h3>Where’s the <code>-&gt;</code> Operator?</h3>
<p>In C and C++, two different operators are used for calling methods: You use
<code>.</code> if you’re calling a method on the object directly and <code>-&gt;</code> if you’re
calling the method on a pointer to the object and need to dereference the
pointer first. In other words, if <code>object</code> is a pointer,
<code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p>Rust doesn’t have an equivalent to the <code>-&gt;</code> operator; instead, Rust has a
feature called <em>automatic referencing and dereferencing</em>. Calling methods is
one of the few places in Rust with this behavior.</p>
<p>Here’s how it works: When you call a method with <code>object.something()</code>, Rust
automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so that <code>object</code> matches the
signature of the method. In other words, the following are the same:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<p>```rust</p>
<h1>#[derive(Debug,Copy,Clone)]</h1>
<h1>struct Point {</h1>
<h1>x: f64,</h1>
<h1>y: f64,</h1>
<h1>}</h1>
<h1></h1>
<h1>impl Point {</h1>
<h1>fn distance(&amp;self, other: &amp;Point) -&gt; f64 {</h1>
<h1>let x_squared = f64::powi(other.x - self.x, 2);</h1>
<h1>let y_squared = f64::powi(other.y - self.y, 2);</h1>
<h1></h1>
<h1>f64::sqrt(x_squared + y_squared)</h1>
<h1>}</h1>
<h1>}</h1>
<h1>let p1 = Point { x: 0.0, y: 0.0 };</h1>
<h1>let p2 = Point { x: 5.0, y: 6.5 };</h1>
<p>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
```</p>
<p>The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver—the type of <code>self</code>. Given the receiver
and name of a method, Rust can figure out definitively whether the method is
reading (<code>&amp;self</code>), mutating (<code>&amp;mut self</code>), or consuming (<code>self</code>). The fact
that Rust makes borrowing implicit for method receivers is a big part of
making ownership ergonomic in practice.</p>
</blockquote>
</body>
</html>