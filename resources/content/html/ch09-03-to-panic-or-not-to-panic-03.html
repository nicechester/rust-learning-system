<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Guidelines for Error Handling</title>
</head>
<body>
<h1>Guidelines for Error Handling</h1>
<p>It’s advisable to have your code panic when it’s possible that your code could
end up in a bad state. In this context, a <em>bad state</em> is when some assumption,
guarantee, contract, or invariant has been broken, such as when invalid values,
contradictory values, or missing values are passed to your code—plus one or
more of the following:</p>
<ul>
<li>The bad state is something that is unexpected, as opposed to something that
  will likely happen occasionally, like a user entering data in the wrong
  format.</li>
<li>Your code after this point needs to rely on not being in this bad state,
  rather than checking for the problem at every step.</li>
<li>There’s not a good way to encode this information in the types you use. We’ll
  work through an example of what we mean in [“Encoding States and Behavior as
  Types”][encoding]<!-- ignore --> in Chapter 18.</li>
</ul>
<p>If someone calls your code and passes in values that don’t make sense, it’s
best to return an error if you can so that the user of the library can decide
what they want to do in that case. However, in cases where continuing could be
insecure or harmful, the best choice might be to call <code>panic!</code> and alert the
person using your library to the bug in their code so that they can fix it
during development. Similarly, <code>panic!</code> is often appropriate if you’re calling
external code that is out of your control and returns an invalid state that you
have no way of fixing.</p>
<p>However, when failure is expected, it’s more appropriate to return a <code>Result</code>
than to make a <code>panic!</code> call. Examples include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, returning a <code>Result</code> indicates that failure is an
expected possibility that the calling code must decide how to handle.</p>
<p>When your code performs an operation that could put a user at risk if it’s
called using invalid values, your code should verify the values are valid first
and panic if the values aren’t valid. This is mostly for safety reasons:
Attempting to operate on invalid data can expose your code to vulnerabilities.
This is the main reason the standard library will call <code>panic!</code> if you attempt
an out-of-bounds memory access: Trying to access memory that doesn’t belong to
the current data structure is a common security problem. Functions often have
<em>contracts</em>: Their behavior is only guaranteed if the inputs meet particular
requirements. Panicking when the contract is violated makes sense because a
contract violation always indicates a caller-side bug, and it’s not a kind of
error you want the calling code to have to explicitly handle. In fact, there’s
no reasonable way for calling code to recover; the calling <em>programmers</em> need
to fix the code. Contracts for a function, especially when a violation will
cause a panic, should be explained in the API documentation for the function.</p>
<p>However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rust’s type system (and thus the type
checking done by the compiler) to do many of the checks for you. If your
function has a particular type as a parameter, you can proceed with your code’s
logic knowing that the compiler has already ensured that you have a valid
value. For example, if you have a type rather than an <code>Option</code>, your program
expects to have <em>something</em> rather than <em>nothing</em>. Your code then doesn’t have
to handle two cases for the <code>Some</code> and <code>None</code> variants: It will only have one
case for definitely having a value. Code trying to pass nothing to your
function won’t even compile, so your function doesn’t have to check for that
case at runtime. Another example is using an unsigned integer type such as
<code>u32</code>, which ensures that the parameter is never negative.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="creating-custom-types-for-validation"></a></p>
</body>
</html>