<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Defining a Trait for Common Behavior</title>
</head>
<body>
<h1>Defining a Trait for Common Behavior</h1>
<p>To implement the behavior that we want <code>gui</code> to have, we’ll define a trait
named <code>Draw</code> that will have one method named <code>draw</code>. Then, we can define a
vector that takes a trait object. A <em>trait object</em> points to both an instance
of a type implementing our specified trait and a table used to look up trait
methods on that type at runtime. We create a trait object by specifying some
sort of pointer, such as a reference or a <code>Box&lt;T&gt;</code> smart pointer, then the
<code>dyn</code> keyword, and then specifying the relevant trait. (We’ll talk about the
reason trait objects must use a pointer in [“Dynamically Sized Types and the
<code>Sized</code> Trait”][dynamically-sized]<!-- ignore --> in Chapter 20.) We can use
trait objects in place of a generic or concrete type. Wherever we use a trait
object, Rust’s type system will ensure at compile time that any value used in
that context will implement the trait object’s trait. Consequently, we don’t
need to know all the possible types at compile time.</p>
<p>We’ve mentioned that, in Rust, we refrain from calling structs and enums
“objects” to distinguish them from other languages’ objects. In a struct or
enum, the data in the struct fields and the behavior in <code>impl</code> blocks are
separated, whereas in other languages, the data and behavior combined into one
concept is often labeled an object. Trait objects differ from objects in other
languages in that we can’t add data to a trait object. Trait objects aren’t as
generally useful as objects in other languages: Their specific purpose is to
allow abstraction across common behavior.</p>
<p>Listing 18-3 shows how to define a trait named <code>Draw</code> with one method named
<code>draw</code>.</p>
<p><Listing number="18-3" file-name="src/lib.rs" caption="Definition of the <code>Draw</code> trait"></p>
<p>```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-03/src/lib.rs}}</p>
<pre><code>
&lt;/Listing&gt;

This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 18-4 defines a struct named
`Screen` that holds a vector named `components`. This vector is of type
`Box&lt;dyn Draw&gt;`, which is a trait object; it’s a stand-in for any type inside a
`Box` that implements the `Draw` trait.

&lt;Listing number=&quot;18-4&quot; file-name=&quot;src/lib.rs&quot; caption=&quot;Definition of the `Screen` struct with a `components` field holding a vector of trait objects that implement the `Draw` trait&quot;&gt;

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-04/src/lib.rs:here}}
</code></pre>
<p></Listing></p>
<p>On the <code>Screen</code> struct, we’ll define a method named <code>run</code> that will call the
<code>draw</code> method on each of its <code>components</code>, as shown in Listing 18-5.</p>
<p><Listing number="18-5" file-name="src/lib.rs" caption="A <code>run</code> method on <code>Screen</code> that calls the <code>draw</code> method on each component"></p>
<p>```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-05/src/lib.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

This works differently from defining a struct that uses a generic type
parameter with trait bounds. A generic type parameter can be substituted with
only one concrete type at a time, whereas trait objects allow for multiple
concrete types to fill in for the trait object at runtime. For example, we
could have defined the `Screen` struct using a generic type and a trait bound,
as in Listing 18-6.

&lt;Listing number=&quot;18-6&quot; file-name=&quot;src/lib.rs&quot; caption=&quot;An alternate implementation of the `Screen` struct and its `run` method using generics and trait bounds&quot;&gt;

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-06/src/lib.rs:here}}
</code></pre>
<p></Listing></p>
<p>This restricts us to a <code>Screen</code> instance that has a list of components all of
type <code>Button</code> or all of type <code>TextField</code>. If you’ll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.</p>
<p>On the other hand, with the method using trait objects, one <code>Screen</code> instance
can hold a <code>Vec&lt;T&gt;</code> that contains a <code>Box&lt;Button&gt;</code> as well as a
<code>Box&lt;TextField&gt;</code>. Let’s look at how this works, and then we’ll talk about the
runtime performance implications.</p>
</body>
</html>