<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Inferring and Annotating Closure Types</title>
</head>
<body>
<h1>Inferring and Annotating Closure Types</h1>
<p>There are more differences between functions and closures. Closures don’t
usually require you to annotate the types of the parameters or the return value
like <code>fn</code> functions do. Type annotations are required on functions because the
types are part of an explicit interface exposed to your users. Defining this
interface rigidly is important for ensuring that everyone agrees on what types
of values a function uses and returns. Closures, on the other hand, aren’t used
in an exposed interface like this: They’re stored in variables, and they’re
used without naming them and exposing them to users of our library.</p>
<p>Closures are typically short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler can
infer the types of the parameters and the return type, similar to how it’s able
to infer the types of most variables (there are rare cases where the compiler
needs closure type annotations too).</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for a closure would look like the definition
shown in Listing 13-2. In this example, we’re defining a closure and storing it
in a variable rather than defining the closure in the spot we pass it as an
argument, as we did in Listing 13-1.</p>
<p><Listing number="13-2" file-name="src/main.rs" caption="Adding optional type annotations of the parameter and return value types in the closure"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. Here, we define a function that adds 1 to its parameter and
a closure that has the same behavior, for comparison. We’ve added some spaces
to line up the relevant parts. This illustrates how closure syntax is similar
to function syntax except for the use of pipes and the amount of syntax that is
optional:</p>
<p>```rust,ignore
fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</p>
<pre><code>
The first line shows a function definition and the second line shows a fully
annotated closure definition. In the third line, we remove the type annotations
from the closure definition. In the fourth line, we remove the brackets, which
are optional because the closure body has only one expression. These are all
valid definitions that will produce the same behavior when they’re called. The
`add_one_v3` and `add_one_v4` lines require the closures to be evaluated to be
able to compile because the types will be inferred from their usage. This is
similar to `let v = Vec::new();` needing either type annotations or values of
some type to be inserted into the `Vec` for Rust to be able to infer the type.

For closure definitions, the compiler will infer one concrete type for each of
their parameters and for their return value. For instance, Listing 13-3 shows
the definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition.
Because there are no type annotations, we can call the closure with any type,
which we’ve done here with `String` the first time. If we then try to call
`example_closure` with an integer, we’ll get an error.

&lt;Listing number=&quot;13-3&quot; file-name=&quot;src/main.rs&quot; caption=&quot;Attempting to call a closure whose types are inferred with two different types&quot;&gt;

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>The compiler gives us this error:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}
</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those
types are then locked into the closure in <code>example_closure</code>, and we get a type
error when we next try to use a different type with the same closure.</p>
</body>
</html>