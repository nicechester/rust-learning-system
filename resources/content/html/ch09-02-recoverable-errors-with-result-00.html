<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Introduction</title>
</head>
<body>
<h1>Introduction</h1>
<h2>Recoverable Errors with <code>Result</code></h2>
<p>Most errors aren’t serious enough to require the program to stop entirely.
Sometimes when a function fails, it’s for a reason that you can easily interpret
and respond to. For example, if you try to open a file and that operation fails
because the file doesn’t exist, you might want to create the file instead of
terminating the process.</p>
<p>Recall from [“Handling Potential Failure with <code>Result</code>”][handle_failure]<!--
ignore --> in Chapter 2 that the <code>Result</code> enum is defined as having two
variants, <code>Ok</code> and <code>Err</code>, as follows:</p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>The <code>T</code> and <code>E</code> are generic type parameters: We’ll discuss generics in more
detail in Chapter 10. What you need to know right now is that <code>T</code> represents
the type of the value that will be returned in a success case within the <code>Ok</code>
variant, and <code>E</code> represents the type of the error that will be returned in a
failure case within the <code>Err</code> variant. Because <code>Result</code> has these generic type
parameters, we can use the <code>Result</code> type and the functions defined on it in
many different situations where the success value and error value we want to
return may differ.</p>
<p>Let’s call a function that returns a <code>Result</code> value because the function could
fail. In Listing 9-3, we try to open a file.</p>
<p><Listing number="9-3" file-name="src/main.rs" caption="Opening a file"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch09-error-handling/listing-09-03/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>The return type of <code>File::open</code> is a <code>Result&lt;T, E&gt;</code>. The generic parameter <code>T</code>
has been filled in by the implementation of <code>File::open</code> with the type of the
success value, <code>std::fs::File</code>, which is a file handle. The type of <code>E</code> used in
the error value is <code>std::io::Error</code>. This return type means the call to
<code>File::open</code> might succeed and return a file handle that we can read from or
write to. The function call also might fail: For example, the file might not
exist, or we might not have permission to access the file. The <code>File::open</code>
function needs to have a way to tell us whether it succeeded or failed and at
the same time give us either the file handle or error information. This
information is exactly what the <code>Result</code> enum conveys.</p>
<p>In the case where <code>File::open</code> succeeds, the value in the variable
<code>greeting_file_result</code> will be an instance of <code>Ok</code> that contains a file handle.
In the case where it fails, the value in <code>greeting_file_result</code> will be an
instance of <code>Err</code> that contains more information about the kind of error that
occurred.</p>
<p>We need to add to the code in Listing 9-3 to take different actions depending
on the value <code>File::open</code> returns. Listing 9-4 shows one way to handle the
<code>Result</code> using a basic tool, the <code>match</code> expression that we discussed in
Chapter 6.</p>
<p><Listing number="9-4" file-name="src/main.rs" caption="Using a <code>match</code> expression to handle the <code>Result</code> variants that might be returned"></p>
<p>```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-04/src/main.rs}}</p>
<pre><code>
&lt;/Listing&gt;

Note that, like the `Option` enum, the `Result` enum and its variants have been
brought into scope by the prelude, so we don’t need to specify `Result::`
before the `Ok` and `Err` variants in the `match` arms.

When the result is `Ok`, this code will return the inner `file` value out of
the `Ok` variant, and we then assign that file handle value to the variable
`greeting_file`. After the `match`, we can use the file handle for reading or
writing.

The other arm of the `match` handles the case where we get an `Err` value from
`File::open`. In this example, we’ve chosen to call the `panic!` macro. If
there’s no file named _hello.txt_ in our current directory and we run this
code, we’ll see the following output from the `panic!` macro:

```console
{{#include ../listings/ch09-error-handling/listing-09-04/output.txt}}
</code></pre>
<p>As usual, this output tells us exactly what has gone wrong.</p>
</body>
</html>