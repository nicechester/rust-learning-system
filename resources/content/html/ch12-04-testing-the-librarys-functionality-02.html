<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Writing Code to Pass the Test</title>
</head>
<body>
<h1>Writing Code to Pass the Test</h1>
<p>Currently, our test is failing because we always return an empty vector. To fix
that and implement <code>search</code>, our program needs to follow these steps:</p>
<ol>
<li>Iterate through each line of the contents.</li>
<li>Check whether the line contains our query string.</li>
<li>If it does, add it to the list of values we’re returning.</li>
<li>If it doesn’t, do nothing.</li>
<li>Return the list of results that match.</li>
</ol>
<p>Let’s work through each step, starting with iterating through lines.</p>
<h4>Iterating Through Lines with the <code>lines</code> Method</h4>
<p>Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named <code>lines</code>, that works as shown in Listing 12-17. Note that
this won’t compile yet.</p>
<p><Listing number="12-17" file-name="src/lib.rs" caption="Iterating through each line in <code>contents</code>"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

The `lines` method returns an iterator. We’ll talk about iterators in depth in
[Chapter 13][ch13-iterators]&lt;!-- ignore --&gt;. But recall that you saw this way
of using an iterator in [Listing 3-5][ch3-iter]&lt;!-- ignore --&gt;, where we used a
`for` loop with an iterator to run some code on each item in a collection.

#### Searching Each Line for the Query

Next, we’ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named `contains` that does this for
us! Add a call to the `contains` method in the `search` function, as shown in
Listing 12-18. Note that this still won’t compile yet.

&lt;Listing number=&quot;12-18&quot; file-name=&quot;src/lib.rs&quot; caption=&quot;Adding functionality to see whether the line contains the string in `query`&quot;&gt;

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}
</code></pre>
<p></Listing></p>
<p>At the moment, we’re building up functionality. To get the code to compile, we
need to return a value from the body as we indicated we would in the function
signature.</p>
<h4>Storing Matching Lines</h4>
<p>To finish this function, we need a way to store the matching lines that we want
to return. For that, we can make a mutable vector before the <code>for</code> loop and
call the <code>push</code> method to store a <code>line</code> in the vector. After the <code>for</code> loop,
we return the vector, as shown in Listing 12-19.</p>
<p><Listing number="12-19" file-name="src/lib.rs" caption="Storing the lines that match so that we can return them"></p>
<p>```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

Now the `search` function should return only the lines that contain `query`,
and our test should pass. Let’s run the test:

```console
{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
</code></pre>
<p>Our test passed, so we know it works!</p>
<p>At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn’t too bad,
but it doesn’t take advantage of some useful features of iterators. We’ll
return to this example in <a href="ch13-02-iterators.html">Chapter 13</a><!-- ignore -->, where
we’ll explore iterators in detail, and look at how to improve it.</p>
<p>Now the entire program should work! Let’s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem: <em>frog</em>.</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
</code></pre>
<p>Cool! Now let’s try a word that will match multiple lines, like <em>body</em>:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
</code></pre>
<p>And finally, let’s make sure that we don’t get any lines when we search for a
word that isn’t anywhere in the poem, such as <em>monomorphization</em>:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
</code></pre>
<p>Excellent! We’ve built our own mini version of a classic tool and learned a lot
about how to structure applications. We’ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.</p>
<p>To round out this project, we’ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you’re writing command line programs.</p>
</body>
</html>