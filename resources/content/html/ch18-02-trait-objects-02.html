<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Implementing the Trait</title>
</head>
<body>
<h1>Implementing the Trait</h1>
<p>Now we’ll add some types that implement the <code>Draw</code> trait. We’ll provide the
<code>Button</code> type. Again, actually implementing a GUI library is beyond the scope
of this book, so the <code>draw</code> method won’t have any useful implementation in its
body. To imagine what the implementation might look like, a <code>Button</code> struct
might have fields for <code>width</code>, <code>height</code>, and <code>label</code>, as shown in Listing 18-7.</p>
<p><Listing number="18-7" file-name="src/lib.rs" caption="A <code>Button</code> struct that implements the <code>Draw</code> trait"></p>
<p>```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-07/src/lib.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

The `width`, `height`, and `label` fields on `Button` will differ from the
fields on other components; for example, a `TextField` type might have those
same fields plus a `placeholder` field. Each of the types we want to draw on
the screen will implement the `Draw` trait but will use different code in the
`draw` method to define how to draw that particular type, as `Button` has here
(without the actual GUI code, as mentioned). The `Button` type, for instance,
might have an additional `impl` block containing methods related to what
happens when a user clicks the button. These kinds of methods won’t apply to
types like `TextField`.

If someone using our library decides to implement a `SelectBox` struct that has
`width`, `height`, and `options` fields, they would implement the `Draw` trait
on the `SelectBox` type as well, as shown in Listing 18-8.

&lt;Listing number=&quot;18-8&quot; file-name=&quot;src/main.rs&quot; caption=&quot;Another crate using `gui` and implementing the `Draw` trait on a `SelectBox` struct&quot;&gt;

```rust,ignore
{{#rustdoc_include ../listings/ch18-oop/listing-18-08/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>Our library’s user can now write their <code>main</code> function to create a <code>Screen</code>
instance. To the <code>Screen</code> instance, they can add a <code>SelectBox</code> and a <code>Button</code>
by putting each in a <code>Box&lt;T&gt;</code> to become a trait object. They can then call the
<code>run</code> method on the <code>Screen</code> instance, which will call <code>draw</code> on each of the
components. Listing 18-9 shows this implementation.</p>
<p><Listing number="18-9" file-name="src/main.rs" caption="Using trait objects to store values of different types that implement the same trait"></p>
<p>```rust,ignore
{{#rustdoc_include ../listings/ch18-oop/listing-18-09/src/main.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

When we wrote the library, we didn’t know that someone might add the
`SelectBox` type, but our `Screen` implementation was able to operate on the
new type and draw it because `SelectBox` implements the `Draw` trait, which
means it implements the `draw` method.

This concept—of being concerned only with the messages a value responds to
rather than the value’s concrete type—is similar to the concept of _duck
typing_ in dynamically typed languages: If it walks like a duck and quacks like
a duck, then it must be a duck! In the implementation of `run` on `Screen` in
Listing 18-5, `run` doesn’t need to know what the concrete type of each
component is. It doesn’t check whether a component is an instance of a `Button`
or a `SelectBox`, it just calls the `draw` method on the component. By
specifying `Box&lt;dyn Draw&gt;` as the type of the values in the `components`
vector, we’ve defined `Screen` to need values that we can call the `draw`
method on.

The advantage of using trait objects and Rust’s type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesn’t implement a method but we call it anyway. Rust won’t compile
our code if the values don’t implement the traits that the trait objects need.

For example, Listing 18-10 shows what happens if we try to create a `Screen`
with a `String` as a component.

&lt;Listing number=&quot;18-10&quot; file-name=&quot;src/main.rs&quot; caption=&quot;Attempting to use a type that doesn’t implement the trait object’s trait&quot;&gt;

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-oop/listing-18-10/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>We’ll get this error because <code>String</code> doesn’t implement the <code>Draw</code> trait:</p>
<pre><code class="language-console">{{#include ../listings/ch18-oop/listing-18-10/output.txt}}
</code></pre>
<p>This error lets us know that either we’re passing something to <code>Screen</code> that we
didn’t mean to pass and so should pass a different type, or we should implement
<code>Draw</code> on <code>String</code> so that <code>Screen</code> is able to call <code>draw</code> on it.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="trait-objects-perform-dynamic-dispatch"></a></p>
</body>
</html>