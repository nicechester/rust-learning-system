<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Implementing the `Deref` Trait</title>
</head>
<body>
<h1>Implementing the `Deref` Trait</h1>
<p>As discussed in [“Implementing a Trait on a Type”][impl-trait]<!-- ignore --> in
Chapter 10, to implement a trait we need to provide implementations for the
trait’s required methods. The <code>Deref</code> trait, provided by the standard library,
requires us to implement one method named <code>deref</code> that borrows <code>self</code> and
returns a reference to the inner data. Listing 15-10 contains an implementation
of <code>Deref</code> to add to the definition of <code>MyBox&lt;T&gt;</code>.</p>
<p><Listing number="15-10" file-name="src/main.rs" caption="Implementing <code>Deref</code> on <code>MyBox&lt;T&gt;</code>"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-10/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>The <code>type Target = T;</code> syntax defines an associated type for the <code>Deref</code> trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you don’t need to worry about them for now; we’ll cover them in
more detail in Chapter 20.</p>
<p>We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so that <code>deref</code>
returns a reference to the value we want to access with the <code>*</code> operator;
recall from [“Creating Different Types with Tuple Structs”][tuple-structs]<!--
ignore --> in Chapter 5 that <code>.0</code> accesses the first value in a tuple struct.
The <code>main</code> function in Listing 15-9 that calls <code>*</code> on the <code>MyBox&lt;T&gt;</code> value now
compiles, and the assertions pass!</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.
The <code>deref</code> method gives the compiler the ability to take a value of any type
that implements <code>Deref</code> and call the <code>deref</code> method to get a reference that
it knows how to dereference.</p>
<p>When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this
code:</p>
<p><code>rust,ignore
*(y.deref())</code></p>
<p>Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a
plain dereference so that we don’t have to think about whether or not we need
to call the <code>deref</code> method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
<code>Deref</code>.</p>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the
plain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary,
has to do with the ownership system. If the <code>deref</code> method returned the value
directly instead of a reference to the value, the value would be moved out of
<code>self</code>. We don’t want to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in
this case or in most cases where we use the dereference operator.</p>
<p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and
then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.
Because the substitution of the <code>*</code> operator does not recurse infinitely, we
end up with data of type <code>i32</code>, which matches the <code>5</code> in <code>assert_eq!</code> in
Listing 15-9.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="implicit-deref-coercions-with-functions-and-methods"></a>
<a id="using-deref-coercions-in-functions-and-methods"></a></p>
</body>
</html>