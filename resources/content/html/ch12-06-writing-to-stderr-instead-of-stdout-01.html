<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Checking Where Errors Are Written</title>
</head>
<body>
<h1>Checking Where Errors Are Written</h1>
<p>First, let’s observe how the content printed by <code>minigrep</code> is currently being
written to standard output, including any error messages we want to write to
standard error instead. We’ll do that by redirecting the standard output stream
to a file while intentionally causing an error. We won’t redirect the standard
error stream, so any content sent to standard error will continue to display on
the screen.</p>
<p>Command line programs are expected to send error messages to the standard error
stream so that we can still see error messages on the screen even if we
redirect the standard output stream to a file. Our program is not currently
well behaved: We’re about to see that it saves the error message output to a
file instead!</p>
<p>To demonstrate this behavior, we’ll run the program with <code>&gt;</code> and the file path,
<em>output.txt</em>, that we want to redirect the standard output stream to. We won’t
pass any arguments, which should cause an error:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>The <code>&gt;</code> syntax tells the shell to write the contents of standard output to
<em>output.txt</em> instead of the screen. We didn’t see the error message we were
expecting printed to the screen, so that means it must have ended up in the
file. This is what <em>output.txt</em> contains:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Yup, our error message is being printed to standard output. It’s much more
useful for error messages like this to be printed to standard error so that
only data from a successful run ends up in the file. We’ll change that.</p>
</body>
</html>