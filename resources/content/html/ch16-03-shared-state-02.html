<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Comparing `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`</title>
</head>
<body>
<h1>Comparing `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`</h1>
<p>You might have noticed that <code>counter</code> is immutable but that we could get a
mutable reference to the value inside it; this means <code>Mutex&lt;T&gt;</code> provides
interior mutability, as the <code>Cell</code> family does. In the same way we used
<code>RefCell&lt;T&gt;</code> in Chapter 15 to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code>, we
use <code>Mutex&lt;T&gt;</code> to mutate contents inside an <code>Arc&lt;T&gt;</code>.</p>
<p>Another detail to note is that Rust can’t protect you from all kinds of logic
errors when you use <code>Mutex&lt;T&gt;</code>. Recall from Chapter 15 that using <code>Rc&lt;T&gt;</code> came
with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to
each other, causing memory leaks. Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of
creating <em>deadlocks</em>. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you’re interested in deadlocks, try creating a Rust
program that has a deadlock; then, research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> offers
useful information.</p>
<p>We’ll round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits and
how we can use them with custom types.</p>
</body>
</html>