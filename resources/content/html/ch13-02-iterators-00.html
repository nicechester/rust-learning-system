<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Introduction</title>
</head>
<body>
<h1>Introduction</h1>
<h2>Processing a Series of Items with Iterators</h2>
<p>The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you don’t
have to reimplement that logic yourself.</p>
<p>In Rust, iterators are <em>lazy</em>, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-10 creates an iterator over the items in the vector <code>v1</code> by calling
the <code>iter</code> method defined on <code>Vec&lt;T&gt;</code>. This code by itself doesn’t do anything
useful.</p>
<p><Listing number="13-10" file-name="src/main.rs" caption="Creating an iterator"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>The iterator is stored in the <code>v1_iter</code> variable. Once we’ve created an
iterator, we can use it in a variety of ways. In Listing 3-5, we iterated over
an array using a <code>for</code> loop to execute some code on each of its items. Under
the hood, this implicitly created and then consumed an iterator, but we glossed
over how exactly that works until now.</p>
<p>In the example in Listing 13-11, we separate the creation of the iterator from
the use of the iterator in the <code>for</code> loop. When the <code>for</code> loop is called using
the iterator in <code>v1_iter</code>, each element in the iterator is used in one
iteration of the loop, which prints out each value.</p>
<p><Listing number="13-11" file-name="src/main.rs" caption="Using an iterator in a <code>for</code> loop"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>In languages that don’t have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.</p>
<p>Iterators handle all of that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Let’s examine how iterators do that.</p>
</body>
</html>