<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Integration Tests</title>
</head>
<body>
<h1>Integration Tests</h1>
<p>In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library’s public API. Their purpose is to test
whether many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a <em>tests</em> directory.</p>
<h4>The <em>tests</em> Directory</h4>
<p>We create a <em>tests</em> directory at the top level of our project directory, next
to <em>src</em>. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want, and Cargo will compile each of the
files as an individual crate.</p>
<p>Let’s create an integration test. With the code in Listing 11-12 still in the
<em>src/lib.rs</em> file, make a <em>tests</em> directory, and create a new file named
<em>tests/integration_test.rs</em>. Your directory structure should look like this:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>Enter the code in Listing 11-13 into the <em>tests/integration_test.rs</em> file.</p>
<p><Listing number="11-13" file-name="tests/integration_test.rs" caption="An integration test of a function in the <code>adder</code> crate"></p>
<p>```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}</p>
<pre><code>
&lt;/Listing&gt;

Each file in the _tests_ directory is a separate crate, so we need to bring our
library into each test crate’s scope. For that reason, we add `use
adder::add_two;` at the top of the code, which we didn’t need in the unit tests.

We don’t need to annotate any code in _tests/integration_test.rs_ with
`#[cfg(test)]`. Cargo treats the _tests_ directory specially and compiles files
in this directory only when we run `cargo test`. Run `cargo test` now:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-13/output.txt}}
</code></pre>
<p>The three sections of output include the unit tests, the integration test, and
the doc tests. Note that if any test in a section fails, the following sections
will not be run. For example, if a unit test fails, there won’t be any output
for integration and doc tests, because those tests will only be run if all unit
tests are passing.</p>
<p>The first section for the unit tests is the same as we’ve been seeing: one line
for each unit test (one named <code>internal</code> that we added in Listing 11-12) and
then a summary line for the unit tests.</p>
<p>The integration tests section starts with the line <code>Running
tests/integration_test.rs</code>. Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the <code>Doc-tests adder</code> section starts.</p>
<p>Each integration test file has its own section, so if we add more files in the
<em>tests</em> directory, there will be more integration test sections.</p>
<p>We can still run a particular integration test function by specifying the test
function’s name as an argument to <code>cargo test</code>. To run all the tests in a
particular integration test file, use the <code>--test</code> argument of <code>cargo test</code>
followed by the name of the file:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt}}
</code></pre>
<p>This command runs only the tests in the <em>tests/integration_test.rs</em> file.</p>
<h4>Submodules in Integration Tests</h4>
<p>As you add more integration tests, you might want to make more files in the
<em>tests</em> directory to help organize them; for example, you can group the test
functions by the functionality they’re testing. As mentioned earlier, each file
in the <em>tests</em> directory is compiled as its own separate crate, which is useful
for creating separate scopes to more closely imitate the way end users will be
using your crate. However, this means files in the <em>tests</em> directory don’t
share the same behavior as files in <em>src</em> do, as you learned in Chapter 7
regarding how to separate code into modules and files.</p>
<p>The different behavior of <em>tests</em> directory files is most noticeable when you
have a set of helper functions to use in multiple integration test files, and
you try to follow the steps in the <a href="ch07-05-separating-modules-into-different-files.html">“Separating Modules into Different
Files”</a><!-- ignore --> section of Chapter 7 to
extract them into a common module. For example, if we create <em>tests/common.rs</em>
and place a function named <code>setup</code> in it, we can add some code to <code>setup</code> that
we want to call from multiple test functions in multiple test files:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<p>```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}</p>
<pre><code>
When we run the tests again, we’ll see a new section in the test output for the
_common.rs_ file, even though this file doesn’t contain any test functions nor
did we call the `setup` function from anywhere:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}
</code></pre>
<p>Having <code>common</code> appear in the test results with <code>running 0 tests</code> displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files. To avoid having <code>common</code> appear in the test output,
instead of creating <em>tests/common.rs</em>, we’ll create <em>tests/common/mod.rs</em>. The
project directory now looks like this:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>This is the older naming convention that Rust also understands that we mentioned
in <a href="ch07-05-separating-modules-into-different-files.html#alternate-file-paths">“Alternate File Paths”</a><!-- ignore --> in Chapter 7. Naming the
file this way tells Rust not to treat the <code>common</code> module as an integration test
file. When we move the <code>setup</code> function code into <em>tests/common/mod.rs</em> and
delete the <em>tests/common.rs</em> file, the section in the test output will no longer
appear. Files in subdirectories of the <em>tests</em> directory don’t get compiled as
separate crates or have sections in the test output.</p>
<p>After we’ve created <em>tests/common/mod.rs</em>, we can use it from any of the
integration test files as a module. Here’s an example of calling the <code>setup</code>
function from the <code>it_adds_two</code> test in <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<p><code>rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}</code></p>
<p>Note that the <code>mod common;</code> declaration is the same as the module declaration
we demonstrated in Listing 7-21. Then, in the test function, we can call the
<code>common::setup()</code> function.</p>
<h4>Integration Tests for Binary Crates</h4>
<p>If our project is a binary crate that only contains a <em>src/main.rs</em> file and
doesn’t have a <em>src/lib.rs</em> file, we can’t create integration tests in the
<em>tests</em> directory and bring functions defined in the <em>src/main.rs</em> file into
scope with a <code>use</code> statement. Only library crates expose functions that other
crates can use; binary crates are meant to be run on their own.</p>
<p>This is one of the reasons Rust projects that provide a binary have a
straightforward <em>src/main.rs</em> file that calls logic that lives in the
<em>src/lib.rs</em> file. Using that structure, integration tests <em>can</em> test the
library crate with <code>use</code> to make the important functionality available. If the
important functionality works, the small amount of code in the <em>src/main.rs</em>
file will work as well, and that small amount of code doesn’t need to be tested.</p>
<h2>Summary</h2>
<p>Rust’s testing features provide a way to specify how code should function to
ensure that it continues to work as you expect, even as you make changes. Unit
tests exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the library’s public API to test the code
in the same way external code will use it. Even though Rust’s type system and
ownership rules help prevent some kinds of bugs, tests are still important to
reduce logic bugs having to do with how your code is expected to behave.</p>
<p>Let’s combine the knowledge you learned in this chapter and in previous
chapters to work on a project!</p>
</body>
</html>