<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Sending Data Between Two Tasks Using Message Passing</title>
</head>
<body>
<h1>Sending Data Between Two Tasks Using Message Passing</h1>
<p>Sharing data between futures will also be familiar: we’ll use message passing
again, but this time with async versions of the types and functions. We’ll take
a slightly different path than we did in the <a href="ch16-02-message-passing.html">“Transfer Data Between Threads
with Message Passing”</a><!-- ignore --> section in
Chapter 16 to illustrate some of the key differences between thread-based and
futures-based concurrency. In Listing 17-9, we’ll begin with just a single
async block—<em>not</em> spawning a separate task as we spawned a separate thread.</p>
<p><Listing number="17-9" caption="Creating an async channel and assigning the two halves to <code>tx</code> and <code>rx</code>" file-name="src/main.rs"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch17-async-await/listing-17-09/src/main.rs:channel}}
</code></pre>
<p></Listing></p>
<p>Here, we use <code>trpl::channel</code>, an async version of the multiple-producer,
single-consumer channel API we used with threads back in Chapter 16. The async
version of the API is only a little different from the thread-based version: it
uses a mutable rather than an immutable receiver <code>rx</code>, and its <code>recv</code> method
produces a future we need to await rather than producing the value directly.
Now we can send messages from the sender to the receiver. Notice that we don’t
have to spawn a separate thread or even a task; we merely need to await the
<code>rx.recv</code> call.</p>
<p>The synchronous <code>Receiver::recv</code> method in <code>std::mpsc::channel</code> blocks until it
receives a message. The <code>trpl::Receiver::recv</code> method does not, because it is
async. Instead of blocking, it hands control back to the runtime until either a
message is received or the send side of the channel closes. By contrast, we
don’t await the <code>send</code> call, because it doesn’t block. It doesn’t need to,
because the channel we’re sending it into is unbounded.</p>
<blockquote>
<p>Note: Because all of this async code runs in an async block in a
<code>trpl::block_on</code> call, everything within it can avoid blocking. However, the
code <em>outside</em> it will block on the <code>block_on</code> function returning. That’s the
whole point of the <code>trpl::block_on</code> function: it lets you <em>choose</em> where to
block on some set of async code, and thus where to transition between sync
and async code.</p>
</blockquote>
<p>Notice two things about this example. First, the message will arrive right
away. Second, although we use a future here, there’s no concurrency yet.
Everything in the listing happens in sequence, just as it would if there were
no futures involved.</p>
<p>Let’s address the first part by sending a series of messages and sleeping in
between them, as shown in Listing 17-10.</p>
<!-- We cannot test this one because it never stops! -->

<p><Listing number="17-10" caption="Sending and receiving multiple messages over the async channel and sleeping with an <code>await</code> between each message" file-name="src/main.rs"></p>
<p>```rust,ignore
{{#rustdoc_include ../listings/ch17-async-await/listing-17-10/src/main.rs:many-messages}}</p>
<pre><code>
&lt;/Listing&gt;

In addition to sending the messages, we need to receive them. In this case,
because we know how many messages are coming in, we could do that manually by
calling `rx.recv().await` four times. In the real world, though, we’ll generally
be waiting on some _unknown_ number of messages, so we need to keep waiting
until we determine that there are no more messages.

In Listing 16-10, we used a `for` loop to process all the items received from a
synchronous channel. Rust doesn’t yet have a way to use a `for` loop with an
_asynchronously produced_ series of items, however, so we need to use a loop we
haven’t seen before: the `while let` conditional loop. This is the loop version
of the `if let` construct we saw back in the [“Concise Control Flow with `if
let` and `let...else`”][if-let]&lt;!-- ignore --&gt; section in Chapter 6. The loop
will continue executing as long as the pattern it specifies continues to match
the value.

The `rx.recv` call produces a future, which we await. The runtime will pause
the future until it is ready. Once a message arrives, the future will resolve
to `Some(message)` as many times as a message arrives. When the channel closes,
regardless of whether _any_ messages have arrived, the future will instead
resolve to `None` to indicate that there are no more values and thus we should
stop polling—that is, stop awaiting.

The `while let` loop pulls all of this together. If the result of calling
`rx.recv().await` is `Some(message)`, we get access to the message and we can
use it in the loop body, just as we could with `if let`. If the result is
`None`, the loop ends. Every time the loop completes, it hits the await point
again, so the runtime pauses it again until another message arrives.

The code now successfully sends and receives all of the messages.
Unfortunately, there are still a couple of problems. For one thing, the
messages do not arrive at half-second intervals. They arrive all at once, 2
seconds (2,000 milliseconds) after we start the program. For another, this
program also never exits! Instead, it waits forever for new messages. You will
need to shut it down using &lt;kbd&gt;ctrl&lt;/kbd&gt;-&lt;kbd&gt;C&lt;/kbd&gt;.

#### Code Within One Async Block Executes Linearly

Let’s start by examining why the messages come in all at once after the full
delay, rather than coming in with delays between each one. Within a given async
block, the order in which `await` keywords appear in the code is also the order
in which they’re executed when the program runs.

There’s only one async block in Listing 17-10, so everything in it runs
linearly. There’s still no concurrency. All the `tx.send` calls happen,
interspersed with all of the `trpl::sleep` calls and their associated await
points. Only then does the `while let` loop get to go through any of the
`await` points on the `recv` calls.

To get the behavior we want, where the sleep delay happens between each
message, we need to put the `tx` and `rx` operations in their own async blocks,
as shown in Listing 17-11. Then the runtime can execute each of them separately
using `trpl::join`, just as in Listing 17-8. Once again, we await the result of
calling `trpl::join`, not the individual futures. If we awaited the individual
futures in sequence, we would just end up back in a sequential flow—exactly
what we’re trying _not_ to do.

&lt;!-- We cannot test this one because it never stops! --&gt;

&lt;Listing number=&quot;17-11&quot; caption=&quot;Separating `send` and `recv` into their own `async` blocks and awaiting the futures for those blocks&quot; file-name=&quot;src/main.rs&quot;&gt;

```rust,ignore
{{#rustdoc_include ../listings/ch17-async-await/listing-17-11/src/main.rs:futures}}
</code></pre>
<p></Listing></p>
<p>With the updated code in Listing 17-11, the messages get printed at
500-millisecond intervals, rather than all in a rush after 2 seconds.</p>
<h4>Moving Ownership Into an Async Block</h4>
<p>The program still never exits, though, because of the way the <code>while let</code> loop
interacts with <code>trpl::join</code>:</p>
<ul>
<li>The future returned from <code>trpl::join</code> completes only once <em>both</em> futures
  passed to it have completed.</li>
<li>The <code>tx_fut</code> future completes once it finishes sleeping after sending the last
  message in <code>vals</code>.</li>
<li>The <code>rx_fut</code> future won’t complete until the <code>while let</code> loop ends.</li>
<li>The <code>while let</code> loop won’t end until awaiting <code>rx.recv</code> produces <code>None</code>.</li>
<li>Awaiting <code>rx.recv</code> will return <code>None</code> only once the other end of the channel
  is closed.</li>
<li>The channel will close only if we call <code>rx.close</code> or when the sender side,
  <code>tx</code>, is dropped.</li>
<li>We don’t call <code>rx.close</code> anywhere, and <code>tx</code> won’t be dropped until the
  outermost async block passed to <code>trpl::block_on</code> ends.</li>
<li>The block can’t end because it is blocked on <code>trpl::join</code> completing, which
  takes us back to the top of this list.</li>
</ul>
<p>Right now, the async block where we send the messages only <em>borrows</em> <code>tx</code>
because sending a message doesn’t require ownership, but if we could <em>move</em>
<code>tx</code> into that async block, it would be dropped once that block ends. In the
<a href="ch13-01-closures.html#capturing-references-or-moving-ownership">“Capturing References or Moving Ownership”</a><!-- ignore -->
section in Chapter 13, you learned how to use the <code>move</code> keyword with closures,
and, as discussed in the <a href="ch16-01-threads.html#using-move-closures-with-threads">“Using <code>move</code> Closures with
Threads”</a><!-- ignore --> section in Chapter 16, we often need to
move data into closures when working with threads. The same basic dynamics
apply to async blocks, so the <code>move</code> keyword works with async blocks just as it
does with closures.</p>
<p>In Listing 17-12, we change the block used to send messages from <code>async</code> to
<code>async move</code>.</p>
<p><Listing number="17-12" caption="A revision of the code from Listing 17-11 that correctly shuts down when complete" file-name="src/main.rs"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch17-async-await/listing-17-12/src/main.rs:with-move}}
</code></pre>
<p></Listing></p>
<p>When we run <em>this</em> version of the code, it shuts down gracefully after the last
message is sent and received. Next, let’s see what would need to change to send
data from more than one future.</p>
<h4>Joining a Number of Futures with the <code>join!</code> Macro</h4>
<p>This async channel is also a multiple-producer channel, so we can call <code>clone</code>
on <code>tx</code> if we want to send messages from multiple futures, as shown in Listing
17-13.</p>
<p><Listing number="17-13" caption="Using multiple producers with async blocks" file-name="src/main.rs"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch17-async-await/listing-17-13/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>First, we clone <code>tx</code>, creating <code>tx1</code> outside the first async block. We move
<code>tx1</code> into that block just as we did before with <code>tx</code>. Then, later, we move the
original <code>tx</code> into a <em>new</em> async block, where we send more messages on a
slightly slower delay. We happen to put this new async block after the async
block for receiving messages, but it could go before it just as well. The key is
the order in which the futures are awaited, not in which they’re created.</p>
<p>Both of the async blocks for sending messages need to be <code>async move</code> blocks so
that both <code>tx</code> and <code>tx1</code> get dropped when those blocks finish. Otherwise, we’ll
end up back in the same infinite loop we started out in.</p>
<p>Finally, we switch from <code>trpl::join</code> to <code>trpl::join!</code> to handle the additional
future: the <code>join!</code> macro awaits an arbitrary number of futures where we know
the number of futures at compile time. We’ll discuss awaiting a collection of
an unknown number of futures later in this chapter.</p>
<p>Now we see all the messages from both sending futures, and because the sending
futures use slightly different delays after sending, the messages are also
received at those different intervals:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>We’ve explored how to use message passing to send data between futures, how
code within an async block runs sequentially, how to move ownership into an
async block, and how to join multiple futures. Next, let’s discuss how and why
to tell the runtime it can switch to another task.</p>
</body>
</html>