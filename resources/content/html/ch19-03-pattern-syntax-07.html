<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Adding Conditionals with Match Guards</title>
</head>
<body>
<h1>Adding Conditionals with Match Guards</h1>
<p>A <em>match guard</em> is an additional <code>if</code> condition, specified after the pattern in
a <code>match</code> arm, that must also match for that arm to be chosen. Match guards are
useful for expressing more complex ideas than a pattern alone allows. Note,
however, that they are only available in <code>match</code> expressions, not <code>if let</code> or
<code>while let</code> expressions.</p>
<p>The condition can use variables created in the pattern. Listing 19-26 shows a
<code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match
guard of <code>if x % 2 == 0</code> (which will be <code>true</code> if the number is even).</p>
<p><Listing number="19-26" caption="Adding a match guard to a pattern"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-26/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>This example will print <code>The number 4 is even</code>. When <code>num</code> is compared to the
pattern in the first arm, it matches because <code>Some(4)</code> matches <code>Some(x)</code>. Then,
the match guard checks whether the remainder of dividing <code>x</code> by 2 is equal to
0, and because it is, the first arm is selected.</p>
<p>If <code>num</code> had been <code>Some(5)</code> instead, the match guard in the first arm would
have been <code>false</code> because the remainder of 5 divided by 2 is 1, which is not
equal to 0. Rust would then go to the second arm, which would match because the
second arm doesn’t have a match guard and therefore matches any <code>Some</code> variant.</p>
<p>There is no way to express the <code>if x % 2 == 0</code> condition within a pattern, so
the match guard gives us the ability to express this logic. The downside of
this additional expressiveness is that the compiler doesn’t try to check for
exhaustiveness when match guard expressions are involved.</p>
<p>When discussing Listing 19-11, we mentioned that we could use match guards to
solve our pattern-shadowing problem. Recall that we created a new variable
inside the pattern in the <code>match</code> expression instead of using the variable
outside the <code>match</code>. That new variable meant we couldn’t test against the value
of the outer variable. Listing 19-27 shows how we can use a match guard to fix
this problem.</p>
<p><Listing number="19-27" file-name="src/main.rs" caption="Using a match guard to test for equality with an outer variable"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-27/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>This code will now print <code>Default case, x = Some(5)</code>. The pattern in the second
match arm doesn’t introduce a new variable <code>y</code> that would shadow the outer <code>y</code>,
meaning we can use the outer <code>y</code> in the match guard. Instead of specifying the
pattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify
<code>Some(n)</code>. This creates a new variable <code>n</code> that doesn’t shadow anything because
there is no <code>n</code> variable outside the <code>match</code>.</p>
<p>The match guard <code>if n == y</code> is not a pattern and therefore doesn’t introduce new
variables. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new <code>y</code> shadowing it, and
we can look for a value that has the same value as the outer <code>y</code> by comparing
<code>n</code> to <code>y</code>.</p>
<p>You can also use the <em>or</em> operator <code>|</code> in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
19-28 shows the precedence when combining a pattern that uses <code>|</code> with a match
guard. The important part of this example is that the <code>if y</code> match guard
applies to <code>4</code>, <code>5</code>, <em>and</em> <code>6</code>, even though it might look like <code>if y</code> only
applies to <code>6</code>.</p>
<p><Listing number="19-28" caption="Combining multiple patterns with a match guard"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-28/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>The match condition states that the arm only matches if the value of <code>x</code> is
equal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the
pattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code>
is <code>false</code>, so the first arm is not chosen. The code moves on to the second
arm, which does match, and this program prints <code>no</code>. The reason is that the
<code>if</code> condition applies to the whole pattern <code>4 | 5 | 6</code>, not just to the last
value <code>6</code>. In other words, the precedence of a match guard in relation to a
pattern behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>After running the code, the precedence behavior is evident: If the match guard
were applied only to the final value in the list of values specified using the
<code>|</code> operator, the arm would have matched, and the program would have printed
<code>yes</code>.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="-bindings"></a></p>
</body>
</html>