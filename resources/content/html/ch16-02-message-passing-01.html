<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Transferring Ownership Through Channels</title>
</head>
<body>
<h1>Transferring Ownership Through Channels</h1>
<p>The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust programs. Let’s do
an experiment to show how channels and ownership work together to prevent
problems: We’ll try to use a <code>val</code> value in the spawned thread <em>after</em> we’ve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isn’t allowed.</p>
<p><Listing number="16-9" file-name="src/main.rs" caption="Attempting to use <code>val</code> after we’ve sent it down the channel"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-09/src/main.rs}}</p>
<pre><code>
&lt;/Listing&gt;

Here, we try to print `val` after we’ve sent it down the channel via `tx.send`.
Allowing this would be a bad idea: Once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread’s modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-09/output.txt}}
</code></pre>
<p>Our concurrency mistake has caused a compile-time error. The <code>send</code> function
takes ownership of its parameter, and when the value is moved the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="sending-multiple-values-and-seeing-the-receiver-waiting"></a></p>
</body>
</html>