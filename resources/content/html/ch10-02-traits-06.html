<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Using Trait Bounds to Conditionally Implement Methods</title>
</head>
<body>
<h1>Using Trait Bounds to Conditionally Implement Methods</h1>
<p>By using a trait bound with an <code>impl</code> block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type <code>Pair&lt;T&gt;</code> in Listing 10-15 always implements the
<code>new</code> function to return a new instance of <code>Pair&lt;T&gt;</code> (recall from the <a href="ch05-03-method-syntax.html#method-syntax">“Method
Syntax”</a><!-- ignore --> section of Chapter 5 that <code>Self</code> is a type
alias for the type of the <code>impl</code> block, which in this case is <code>Pair&lt;T&gt;</code>). But
in the next <code>impl</code> block, <code>Pair&lt;T&gt;</code> only implements the <code>cmp_display</code> method if
its inner type <code>T</code> implements the <code>PartialOrd</code> trait that enables comparison
<em>and</em> the <code>Display</code> trait that enables printing.</p>
<p><Listing number="10-15" file-name="src/lib.rs" caption="Conditionally implementing methods on a generic type depending on trait bounds"></p>
<p>```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}</p>
<pre><code>
&lt;/Listing&gt;

We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called _blanket implementations_ and are used extensively in the
Rust standard library. For example, the standard library implements the
`ToString` trait on any type that implements the `Display` trait. The `impl`
block in the standard library looks similar to this code:

```rust,ignore
impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Because the standard library has this blanket implementation, we can call the
<code>to_string</code> method defined by the <code>ToString</code> trait on any type that implements
the <code>Display</code> trait. For example, we can turn integers into their corresponding
<code>String</code> values like this because integers implement <code>Display</code>:</p>
<pre><code class="language-rust">let s = 3.to_string();
</code></pre>
<p>Blanket implementations appear in the documentation for the trait in the
“Implementors” section.</p>
<p>Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type that didn’t define the method. But Rust
moves these errors to compile time so that we’re forced to fix the problems
before our code is even able to run. Additionally, we don’t have to write code
that checks for behavior at runtime, because we’ve already checked at compile
time. Doing so improves performance without having to give up the flexibility
of generics.</p>
</body>
</html>