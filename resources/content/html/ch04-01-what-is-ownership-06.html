<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Return Values and Scope</title>
</head>
<body>
<h1>Return Values and Scope</h1>
<p>Returning values can also transfer ownership. Listing 4-4 shows an example of a
function that returns some value, with similar annotations as those in Listing
4-3.</p>
<p><Listing number="4-4" file-name="src/main.rs" caption="Transferring ownership of return values"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>The ownership of a variable follows the same pattern every time: Assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by <code>drop</code> unless ownership
of the data has been moved to another variable.</p>
<p>While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but
not take ownership? Itâ€™s quite annoying that anything we pass in also needs to
be passed back if we want to use it again, in addition to any data resulting
from the body of the function that we might want to return as well.</p>
<p>Rust does let us return multiple values using a tuple, as shown in Listing 4-5.</p>
<p><Listing number="4-5" file-name="src/main.rs" caption="Returning ownership of parameters"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for using a value without
transferring ownership: references.</p>
</body>
</html>