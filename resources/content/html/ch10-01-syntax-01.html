<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>In Function Definitions</title>
</head>
<body>
<h1>In Function Definitions</h1>
<p>When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.</p>
<p>Continuing with our <code>largest</code> function, Listing 10-4 shows two functions that
both find the largest value in a slice. We’ll then combine these into a single
function that uses generics.</p>
<p><Listing number="10-4" file-name="src/main.rs" caption="Two functions that differ only in their names and in the types in their signatures"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>The <code>largest_i32</code> function is the one we extracted in Listing 10-3 that finds
the largest <code>i32</code> in a slice. The <code>largest_char</code> function finds the largest
<code>char</code> in a slice. The function bodies have the same code, so let’s eliminate
the duplication by introducing a generic type parameter in a single function.</p>
<p>To parameterize the types in a new single function, we need to name the type
parameter, just as we do for the value parameters to a function. You can use
any identifier as a type parameter name. But we’ll use <code>T</code> because, by
convention, type parameter names in Rust are short, often just one letter, and
Rust’s type-naming convention is UpperCamelCase. Short for <em>type</em>, <code>T</code> is the
default choice of most Rust programmers.</p>
<p>When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so that the compiler knows what that name
means. Similarly, when we use a type parameter name in a function signature, we
have to declare the type parameter name before we use it. To define the generic
<code>largest</code> function, we place type name declarations inside angle brackets,
<code>&lt;&gt;</code>, between the name of the function and the parameter list, like this:</p>
<p>```rust,ignore
fn largest<T>(list: &amp;[T]) -&gt; &amp;T {</p>
<pre><code>
We read this definition as “The function `largest` is generic over some type
`T`.” This function has one parameter named `list`, which is a slice of values
of type `T`. The `largest` function will return a reference to a value of the
same type `T`.

Listing 10-5 shows the combined `largest` function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of `i32` values or `char` values. Note that this code won’t
compile yet.

&lt;Listing number=&quot;10-5&quot; file-name=&quot;src/main.rs&quot; caption=&quot;The `largest` function using generic type parameters; this doesn’t compile yet&quot;&gt;

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>If we compile this code right now, we’ll get this error:</p>
<pre><code class="language-console">{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
</code></pre>
<p>The help text mentions <code>std::cmp::PartialOrd</code>, which is a trait, and we’re
going to talk about traits in the next section. For now, know that this error
states that the body of <code>largest</code> won’t work for all possible types that <code>T</code>
could be. Because we want to compare values of type <code>T</code> in the body, we can
only use types whose values can be ordered. To enable comparisons, the standard
library has the <code>std::cmp::PartialOrd</code> trait that you can implement on types
(see Appendix C for more on this trait). To fix Listing 10-5, we can follow the
help text’s suggestion and restrict the types valid for <code>T</code> to only those that
implement <code>PartialOrd</code>. The listing will then compile, because the standard
library implements <code>PartialOrd</code> on both <code>i32</code> and <code>char</code>.</p>
</body>
</html>