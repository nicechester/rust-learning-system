<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>`let` Statements</title>
</head>
<body>
<h1>`let` Statements</h1>
<p>Prior to this chapter, we had only explicitly discussed using patterns with
<code>match</code> and <code>if let</code>, but in fact, we’ve used patterns in other places as well,
including in <code>let</code> statements. For example, consider this straightforward
variable assignment with <code>let</code>:</p>
<pre><code class="language-rust">let x = 5;
</code></pre>
<p>Every time you’ve used a <code>let</code> statement like this you’ve been using patterns,
although you might not have realized it! More formally, a <code>let</code> statement looks
like this:</p>
<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->

<pre>
<code>let <em>PATTERN</em> = <em>EXPRESSION</em>;</code>
</pre>

<p>In statements like <code>let x = 5;</code> with a variable name in the PATTERN slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So, in the
<code>let x = 5;</code> example, <code>x</code> is a pattern that means “bind what matches here to
the variable <code>x</code>.” Because the name <code>x</code> is the whole pattern, this pattern
effectively means “bind everything to the variable <code>x</code>, whatever the value is.”</p>
<p>To see the pattern-matching aspect of <code>let</code> more clearly, consider Listing
19-1, which uses a pattern with <code>let</code> to destructure a tuple.</p>
<p><Listing number="19-1" caption="Using a pattern to destructure a tuple and create three variables at once"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-01/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>Here, we match a tuple against a pattern. Rust compares the value <code>(1, 2, 3)</code>
to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern—that is,
it sees that the number of elements is the same in both—so Rust binds <code>1</code> to
<code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>. You can think of this tuple pattern as nesting
three individual variable patterns inside it.</p>
<p>If the number of elements in the pattern doesn’t match the number of elements
in the tuple, the overall type won’t match and we’ll get a compiler error. For
example, Listing 19-2 shows an attempt to destructure a tuple with three
elements into two variables, which won’t work.</p>
<p><Listing number="19-2" caption="Incorrectly constructing a pattern whose variables don’t match the number of elements in the tuple"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-02/src/main.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

Attempting to compile this code results in this type error:

```console
{{#include ../listings/ch19-patterns-and-matching/listing-19-02/output.txt}}
</code></pre>
<p>To fix the error, we could ignore one or more of the values in the tuple using
<code>_</code> or <code>..</code>, as you’ll see in the [“Ignoring Values in a
Pattern”][ignoring-values-in-a-pattern]<!-- ignore --> section. If the problem
is that we have too many variables in the pattern, the solution is to make the
types match by removing variables so that the number of variables equals the
number of elements in the tuple.</p>
</body>
</html>