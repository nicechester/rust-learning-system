<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Exposing Paths with the `pub` Keyword</title>
</head>
<body>
<h1>Exposing Paths with the `pub` Keyword</h1>
<p>Let’s return to the error in Listing 7-4 that told us the <code>hosting</code> module is
private. We want the <code>eat_at_restaurant</code> function in the parent module to have
access to the <code>add_to_waitlist</code> function in the child module, so we mark the
<code>hosting</code> module with the <code>pub</code> keyword, as shown in Listing 7-5.</p>
<p><Listing number="7-5" file-name="src/lib.rs" caption="Declaring the <code>hosting</code> module as <code>pub</code> to use it from <code>eat_at_restaurant</code>"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-05/src/lib.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

Unfortunately, the code in Listing 7-5 still results in compiler errors, as
shown in Listing 7-6.

&lt;Listing number=&quot;7-6&quot; caption=&quot;Compiler errors from building the code in Listing 7-5&quot;&gt;

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-05/output.txt}}
</code></pre>
<p></Listing></p>
<p>What happened? Adding the <code>pub</code> keyword in front of <code>mod hosting</code> makes the
module public. With this change, if we can access <code>front_of_house</code>, we can
access <code>hosting</code>. But the <em>contents</em> of <code>hosting</code> are still private; making the
module public doesn’t make its contents public. The <code>pub</code> keyword on a module
only lets code in its ancestor modules refer to it, not access its inner code.
Because modules are containers, there’s not much we can do by only making the
module public; we need to go further and choose to make one or more of the
items within the module public as well.</p>
<p>The errors in Listing 7-6 say that the <code>add_to_waitlist</code> function is private.
The privacy rules apply to structs, enums, functions, and methods as well as
modules.</p>
<p>Let’s also make the <code>add_to_waitlist</code> function public by adding the <code>pub</code>
keyword before its definition, as in Listing 7-7.</p>
<p><Listing number="7-7" file-name="src/lib.rs" caption="Adding the <code>pub</code> keyword to <code>mod hosting</code> and <code>fn add_to_waitlist</code> lets us call the function from <code>eat_at_restaurant</code>."></p>
<p><code>rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-07/src/lib.rs:here}}</code></p>
<p></Listing></p>
<p>Now the code will compile! To see why adding the <code>pub</code> keyword lets us use
these paths in <code>eat_at_restaurant</code> with respect to the privacy rules, let’s
look at the absolute and the relative paths.</p>
<p>In the absolute path, we start with <code>crate</code>, the root of our crate’s module
tree. The <code>front_of_house</code> module is defined in the crate root. While
<code>front_of_house</code> isn’t public, because the <code>eat_at_restaurant</code> function is
defined in the same module as <code>front_of_house</code> (that is, <code>eat_at_restaurant</code>
and <code>front_of_house</code> are siblings), we can refer to <code>front_of_house</code> from
<code>eat_at_restaurant</code>. Next is the <code>hosting</code> module marked with <code>pub</code>. We can
access the parent module of <code>hosting</code>, so we can access <code>hosting</code>. Finally, the
<code>add_to_waitlist</code> function is marked with <code>pub</code>, and we can access its parent
module, so this function call works!</p>
<p>In the relative path, the logic is the same as the absolute path except for the
first step: Rather than starting from the crate root, the path starts from
<code>front_of_house</code>. The <code>front_of_house</code> module is defined within the same module
as <code>eat_at_restaurant</code>, so the relative path starting from the module in which
<code>eat_at_restaurant</code> is defined works. Then, because <code>hosting</code> and
<code>add_to_waitlist</code> are marked with <code>pub</code>, the rest of the path works, and this
function call is valid!</p>
<p>If you plan to share your library crate so that other projects can use your
code, your public API is your contract with users of your crate that determines
how they can interact with your code. There are many considerations around
managing changes to your public API to make it easier for people to depend on
your crate. These considerations are beyond the scope of this book; if you’re
interested in this topic, see [the Rust API Guidelines][api-guidelines].</p>
<blockquote>
<h4>Best Practices for Packages with a Binary and a Library</h4>
<p>We mentioned that a package can contain both a <em>src/main.rs</em> binary crate
root as well as a <em>src/lib.rs</em> library crate root, and both crates will have
the package name by default. Typically, packages with this pattern of
containing both a library and a binary crate will have just enough code in the
binary crate to start an executable that calls code defined in the library
crate. This lets other projects benefit from the most functionality that the
package provides because the library crate’s code can be shared.</p>
<p>The module tree should be defined in <em>src/lib.rs</em>. Then, any public items can
be used in the binary crate by starting paths with the name of the package.
The binary crate becomes a user of the library crate just like a completely
external crate would use the library crate: It can only use the public API.
This helps you design a good API; not only are you the author, but you’re
also a client!</p>
<p>In [Chapter 12][ch12]<!-- ignore -->, we’ll demonstrate this organizational
practice with a command line program that will contain both a binary crate
and a library crate.</p>
</blockquote>
</body>
</html>