<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Using `move` Closures with Threads</title>
</head>
<body>
<h1>Using `move` Closures with Threads</h1>
<p>We’ll often use the <code>move</code> keyword with closures passed to <code>thread::spawn</code>
because the closure will then take ownership of the values it uses from the
environment, thus transferring ownership of those values from one thread to
another. In <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">“Capturing References or Moving Ownership”</a><!-- ignore
--> in Chapter 13, we discussed <code>move</code> in the context of closures. Now we’ll
concentrate more on the interaction between <code>move</code> and <code>thread::spawn</code>.</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no
arguments: We’re not using any data from the main thread in the spawned
thread’s code. To use data from the main thread in the spawned thread, the
spawned thread’s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won’t work yet, as you’ll see in a moment.</p>
<p><Listing number="16-3" file-name="src/main.rs" caption="Attempting to use a vector created by the main thread in another thread"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-03/src/main.rs}}</p>
<pre><code>
&lt;/Listing&gt;

The closure uses `v`, so it will capture `v` and make it part of the closure’s
environment. Because `thread::spawn` runs this closure in a new thread, we
should be able to access `v` inside that new thread. But when we compile this
example, we get the following error:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-03/output.txt}}
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference
to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know whether the
reference to <code>v</code> will always be valid.</p>
<p>Listing 16-4 provides a scenario that’s more likely to have a reference to <code>v</code>
that won’t be valid.</p>
<p><Listing number="16-4" file-name="src/main.rs" caption="A thread with a closure that attempts to capture a reference to <code>v</code> from a main thread that drops <code>v</code>"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-04/src/main.rs}}</p>
<pre><code>
&lt;/Listing&gt;

If Rust allowed us to run this code, there’s a possibility that the spawned
thread would be immediately put in the background without running at all. The
spawned thread has a reference to `v` inside, but the main thread immediately
drops `v`, using the `drop` function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, `v` is no longer valid, so a reference to it
is also invalid. Oh no!

To fix the compiler error in Listing 16-3, we can use the error message’s
advice:

&lt;!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
--&gt;

```text
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend.</p>
<p><Listing number="16-5" file-name="src/main.rs" caption="Using the <code>move</code> keyword to force a closure to take ownership of the values it uses"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-05/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>We might be tempted to try the same thing to fix the code in Listing 16-4 where
the main thread called <code>drop</code> by using a <code>move</code> closure. However, this fix will
not work because what Listing 16-4 is trying to do is disallowed for a
different reason. If we added <code>move</code> to the closure, we would move <code>v</code> into the
closure’s environment, and we could no longer call <code>drop</code> on it in the main
thread. We would get this compiler error instead:</p>
<pre><code class="language-console">{{#include ../listings/ch16-fearless-concurrency/output-only-01-move-drop/output.txt}}
</code></pre>
<p>Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of <code>v</code> to the spawned
thread, we’re guaranteeing to Rust that the main thread won’t use <code>v</code> anymore.
If we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use <code>v</code> in the main thread. The <code>move</code> keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.</p>
<p>Now that we’ve covered what threads are and the methods supplied by the thread
API, let’s look at some situations in which we can use threads.</p>
</body>
</html>