<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Implementing External Traits with the Newtype Pattern</title>
</head>
<body>
<h1>Implementing External Traits with the Newtype Pattern</h1>
<p>In the <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“Implementing a Trait on a Type”</a><!--
ignore --> section in Chapter 10, we mentioned the orphan rule that states
we’re only allowed to implement a trait on a type if either the trait or the
type, or both, are local to our crate. It’s possible to get around this
restriction using the newtype pattern, which involves creating a new type in a
tuple struct. (We covered tuple structs in the <a href="ch05-01-defining-structs.html#creating-different-types-with-tuple-structs">“Creating Different Types with
Tuple Structs”</a><!-- ignore --> section in Chapter 5.) The tuple
struct will have one field and be a thin wrapper around the type for which we
want to implement a trait. Then, the wrapper type is local to our crate, and we
can implement the trait on the wrapper. <em>Newtype</em> is a term that originates
from the Haskell programming language. There is no runtime performance penalty
for using this pattern, and the wrapper type is elided at compile time.</p>
<p>As an example, let’s say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the
orphan rule prevents us from doing directly because the <code>Display</code> trait and the
<code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct
that holds an instance of <code>Vec&lt;T&gt;</code>; then, we can implement <code>Display</code> on
<code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 20-24.</p>
<p><Listing number="20-24" file-name="src/main.rs" caption="Creating a <code>Wrapper</code> type around <code>Vec&lt;String&gt;</code> to implement <code>Display</code>"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-24/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code>
because <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the
tuple. Then, we can use the functionality of the <code>Display</code> trait on <code>Wrapper</code>.</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it
doesn’t have the methods of the value it’s holding. We would have to implement
all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods
delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a
<code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has,
implementing the <code>Deref</code> trait on the <code>Wrapper</code> to return the inner type would
be a solution (we discussed implementing the <code>Deref</code> trait in the <a href="ch15-02-deref.html#treating-smart-pointers-like-regular-references">“Treating
Smart Pointers Like Regular References”</a><!-- ignore -->
section in Chapter 15). If we didn’t want the <code>Wrapper</code> type to have all the
methods of the inner type—for example, to restrict the <code>Wrapper</code> type’s
behavior—we would have to implement just the methods we do want manually.</p>
<p>This newtype pattern is also useful even when traits are not involved. Let’s
switch focus and look at some advanced ways to interact with Rust’s type system.</p>
</body>
</html>