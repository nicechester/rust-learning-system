<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Function Pointers</title>
</head>
<body>
<h1>Function Pointers</h1>
<p>We’ve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function you’ve already defined rather than defining a new closure. Functions
coerce to the type <code>fn</code> (with a lowercase <em>f</em>), not to be confused with the
<code>Fn</code> closure trait. The <code>fn</code> type is called a <em>function pointer</em>. Passing
functions with function pointers will allow you to use functions as arguments
to other functions.</p>
<p>The syntax for specifying that a parameter is a function pointer is similar to
that of closures, as shown in Listing 20-28, where we’ve defined a function
<code>add_one</code> that adds 1 to its parameter. The function <code>do_twice</code> takes two
parameters: a function pointer to any function that takes an <code>i32</code> parameter
and returns an <code>i32</code>, and one <code>i32</code> value. The <code>do_twice</code> function calls the
function <code>f</code> twice, passing it the <code>arg</code> value, then adds the two function call
results together. The <code>main</code> function calls <code>do_twice</code> with the arguments
<code>add_one</code> and <code>5</code>.</p>
<p><Listing number="20-28" file-name="src/main.rs" caption="Using the <code>fn</code> type to accept a function pointer as an argument"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-28/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>This code prints <code>The answer is: 12</code>. We specify that the parameter <code>f</code> in
<code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an
<code>i32</code>. We can then call <code>f</code> in the body of <code>do_twice</code>. In <code>main</code>, we can pass
the function name <code>add_one</code> as the first argument to <code>do_twice</code>.</p>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the
parameter type directly rather than declaring a generic type parameter with one
of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>), meaning you can always pass a function pointer as an argument for a
function that expects a closure. It’s best to write functions using a generic
type and one of the closure traits so that your functions can accept either
functions or closures.</p>
<p>That said, one example of where you would want to only accept <code>fn</code> and not
closures is when interfacing with external code that doesn’t have closures: C
functions can accept functions as arguments, but C doesn’t have closures.</p>
<p>As an example of where you could use either a closure defined inline or a named
function, let’s look at a use of the <code>map</code> method provided by the <code>Iterator</code>
trait in the standard library. To use the <code>map</code> method to turn a vector of
numbers into a vector of strings, we could use a closure, as in Listing 20-29.</p>
<p><Listing number="20-29" caption="Using a closure with the <code>map</code> method to convert numbers to strings"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-29/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>Or we could name a function as the argument to <code>map</code> instead of the closure.
Listing 20-30 shows what this would look like.</p>
<p><Listing number="20-30" caption="Using the <code>String::to_string</code> function with the <code>map</code> method to convert numbers to strings"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-30/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>Note that we must use the fully qualified syntax that we talked about in the
[“Advanced Traits”][advanced-traits]<!-- ignore --> section because there are
multiple functions available named <code>to_string</code>.</p>
<p>Here, we’re using the <code>to_string</code> function defined in the <code>ToString</code> trait,
which the standard library has implemented for any type that implements
<code>Display</code>.</p>
<p>Recall from the [“Enum Values”][enum-values]<!-- ignore --> section in Chapter
6 that the name of each enum variant that we define also becomes an initializer
function. We can use these initializer functions as function pointers that
implement the closure traits, which means we can specify the initializer
functions as arguments for methods that take closures, as seen in Listing 20-31.</p>
<p><Listing number="20-31" caption="Using an enum initializer with the <code>map</code> method to create a <code>Status</code> instance from numbers"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-31/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>Here, we create <code>Status::Value</code> instances using each <code>u32</code> value in the range
that <code>map</code> is called on by using the initializer function of <code>Status::Value</code>.
Some people prefer this style and some people prefer to use closures. They
compile to the same code, so use whichever style is clearer to you.</p>
</body>
</html>