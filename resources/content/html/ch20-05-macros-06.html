<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Function-Like Macros</title>
</head>
<body>
<h1>Function-Like Macros</h1>
<p>Function-like macros define macros that look like function calls. Similarly to
<code>macro_rules!</code> macros, they’re more flexible than functions; for example, they
can take an unknown number of arguments. However, <code>macro_rules!</code> macros can
only be defined using the match-like syntax we discussed in the <a href="#declarative-macros-with-macro_rules-for-general-metaprogramming">“Declarative
Macros for General Metaprogramming”</a><!-- ignore --> section earlier.
Function-like macros take a <code>TokenStream</code> parameter, and their definition
manipulates that <code>TokenStream</code> using Rust code as the other two types of
procedural macros do. An example of a function-like macro is an <code>sql!</code> macro
that might be called like so:</p>
<p>```rust,ignore
let sql = sql!(SELECT * FROM posts WHERE id=1);</p>
<pre><code>
This macro would parse the SQL statement inside it and check that it’s
syntactically correct, which is much more complex processing than a
`macro_rules!` macro can do. The `sql!` macro would be defined like this:

```rust,ignore
#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<p>This definition is similar to the custom <code>derive</code> macro’s signature: We receive
the tokens that are inside the parentheses and return the code we wanted to
generate.</p>
<h2>Summary</h2>
<p>Whew! Now you have some Rust features in your toolbox that you likely won’t use
often, but you’ll know they’re available in very particular circumstances.
We’ve introduced several complex topics so that when you encounter them in
error message suggestions or in other people’s code, you’ll be able to
recognize these concepts and syntax. Use this chapter as a reference to guide
you to solutions.</p>
<p>Next, we’ll put everything we’ve discussed throughout the book into practice
and do one more project!</p>
</body>
</html>