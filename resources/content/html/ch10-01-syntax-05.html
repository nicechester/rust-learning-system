<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Performance of Code Using Generics</title>
</head>
<body>
<h1>Performance of Code Using Generics</h1>
<p>You might be wondering whether there is a runtime cost when using generic type
parameters. The good news is that using generic types won’t make your program
run any slower than it would with concrete types.</p>
<p>Rust accomplishes this by performing monomorphization of the code using
generics at compile time. <em>Monomorphization</em> is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled. In this process, the compiler does the opposite of the steps we used
to create the generic function in Listing 10-5: The compiler looks at all the
places where generic code is called and generates code for the concrete types
the generic code is called with.</p>
<p>Let’s look at how this works by using the standard library’s generic
<code>Option&lt;T&gt;</code> enum:</p>
<pre><code class="language-rust">let integer = Some(5);
let float = Some(5.0);
</code></pre>
<p>When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in <code>Option&lt;T&gt;</code>
instances and identifies two kinds of <code>Option&lt;T&gt;</code>: One is <code>i32</code> and the other
is <code>f64</code>. As such, it expands the generic definition of <code>Option&lt;T&gt;</code> into two
definitions specialized to <code>i32</code> and <code>f64</code>, thereby replacing the generic
definition with the specific ones.</p>
<p>The monomorphized version of the code looks similar to the following (the
compiler uses different names than what we’re using here for illustration):</p>
<p><Listing file-name="src/main.rs"></p>
<pre><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre>
<p></Listing></p>
<p>The generic <code>Option&lt;T&gt;</code> is replaced with the specific definitions created by
the compiler. Because Rust compiles generic code into code that specifies the
type in each instance, we pay no runtime cost for using generics. When the code
runs, it performs just as it would if we had duplicated each definition by
hand. The process of monomorphization makes Rust’s generics extremely efficient
at runtime.</p>
</body>
</html>