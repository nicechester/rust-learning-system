<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>The `String` Type</title>
</head>
<body>
<h1>The `String` Type</h1>
<p>To illustrate the rules of ownership, we need a data type that is more complex
than those we covered in the [“Data Types”][data-types]<!-- ignore --> section
of Chapter 3. The types covered previously are of a known size, can be stored
on the stack and popped off the stack when their scope is over, and can be
quickly and trivially copied to make a new, independent instance if another
part of code needs to use the same value in a different scope. But we want to
look at data that is stored on the heap and explore how Rust knows when to
clean up that data, and the <code>String</code> type is a great example.</p>
<p>We’ll concentrate on the parts of <code>String</code> that relate to ownership. These
aspects also apply to other complex data types, whether they are provided by
the standard library or created by you. We’ll discuss non-ownership aspects of
<code>String</code> in [Chapter 8][ch8]<!-- ignore -->.</p>
<p>We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable. Another is that not every string value can be known when we write
our code: For example, what if we want to take user input and store it? It is
for these situations that Rust has the <code>String</code> type. This type manages
data allocated on the heap and as such is able to store an amount of text that
is unknown to us at compile time. You can create a <code>String</code> from a string
literal using the <code>from</code> function, like so:</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
</code></pre>
<p>The double colon <code>::</code> operator allows us to namespace this particular <code>from</code>
function under the <code>String</code> type rather than using some sort of name like
<code>string_from</code>. We’ll discuss this syntax more in the [“Methods”][methods]<!--
ignore --> section of Chapter 5, and when we talk about namespacing with
modules in [“Paths for Referring to an Item in the Module
Tree”][paths-module-tree]<!-- ignore --> in Chapter 7.</p>
<p>This kind of string <em>can</em> be mutated:</p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}
</code></pre>
<p>So, what’s the difference here? Why can <code>String</code> be mutated but literals
cannot? The difference is in how these two types deal with memory.</p>
</body>
</html>