<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Enabling Recursive Types with Boxes</title>
</head>
<body>
<h1>Enabling Recursive Types with Boxes</h1>
<p>A value of a <em>recursive type</em> can have another value of the same type as part of
itself. Recursive types pose an issue because Rust needs to know at compile time
how much space a type takes up. However, the nesting of values of recursive
types could theoretically continue infinitely, so Rust can’t know how much space
the value needs. Because boxes have a known size, we can enable recursive types
by inserting a box in the recursive type definition.</p>
<p>As an example of a recursive type, let’s explore the cons list. This is a data
type commonly found in functional programming languages. The cons list type
we’ll define is straightforward except for the recursion; therefore, the
concepts in the example we’ll work with will be useful anytime you get into
more complex situations involving recursive types.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="more-information-about-the-cons-list"></a></p>
<h4>Understanding the Cons List</h4>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language
and its dialects, is made up of nested pairs, and is the Lisp version of a
linked list. Its name comes from the <code>cons</code> function (short for <em>construct
function</em>) in Lisp that constructs a new pair from its two arguments. By
calling <code>cons</code> on a pair consisting of a value and another pair, we can
construct cons lists made up of recursive pairs.</p>
<p>For example, here’s a pseudocode representation of a cons list containing the
list <code>1, 2, 3</code> with each pair in parentheses:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Each item in a cons list contains two elements: the value of the current item
and of the next item. The last item in the list contains only a value called
<code>Nil</code> without a next item. A cons list is produced by recursively calling the
<code>cons</code> function. The canonical name to denote the base case of the recursion is
<code>Nil</code>. Note that this is not the same as the “null” or “nil” concept discussed
in Chapter 6, which is an invalid or absent value.</p>
<p>The cons list isn’t a commonly used data structure in Rust. Most of the time
when you have a list of items in Rust, <code>Vec&lt;T&gt;</code> is a better choice to use.
Other, more complex recursive data types <em>are</em> useful in various situations,
but by starting with the cons list in this chapter, we can explore how boxes
let us define a recursive data type without much distraction.</p>
<p>Listing 15-2 contains an enum definition for a cons list. Note that this code
won’t compile yet, because the <code>List</code> type doesn’t have a known size, which
we’ll demonstrate.</p>
<p><Listing number="15-2" file-name="src/main.rs" caption="The first attempt at defining an enum to represent a cons list data structure of <code>i32</code> values"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-02/src/main.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

&gt; Note: We’re implementing a cons list that holds only `i32` values for the
&gt; purposes of this example. We could have implemented it using generics, as we
&gt; discussed in Chapter 10, to define a cons list type that could store values of
&gt; any type.

Using the `List` type to store the list `1, 2, 3` would look like the code in
Listing 15-3.

&lt;Listing number=&quot;15-3&quot; file-name=&quot;src/main.rs&quot; caption=&quot;Using the `List` enum to store the list `1, 2, 3`&quot;&gt;

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-03/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code> value is
another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This <code>List</code> value
is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally
<code>Nil</code>, the non-recursive variant that signals the end of the list.</p>
<p>If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4.</p>
<p><Listing number="15-4" caption="The error we get when attempting to define a recursive enum"></p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-03/output.txt}}
</code></pre>
<p></Listing></p>
<p>The error shows this type “has infinite size.” The reason is that we’ve defined
<code>List</code> with a variant that is recursive: It holds another value of itself
directly. As a result, Rust can’t figure out how much space it needs to store a
<code>List</code> value. Let’s break down why we get this error. First, we’ll look at how
Rust decides how much space it needs to store a value of a non-recursive type.</p>
<h4>Computing the Size of a Non-Recursive Type</h4>
<p>Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:</p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
</code></pre>
<p>To determine how much space to allocate for a <code>Message</code> value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that <code>Message::Quit</code> doesn’t need any space, <code>Message::Move</code> needs enough
space to store two <code>i32</code> values, and so forth. Because only one variant will be
used, the most space a <code>Message</code> value will need is the space it would take to
store the largest of its variants.</p>
<p>Contrast this with what happens when Rust tries to determine how much space a
recursive type like the <code>List</code> enum in Listing 15-2 needs. The compiler starts
by looking at the <code>Cons</code> variant, which holds a value of type <code>i32</code> and a value
of type <code>List</code>. Therefore, <code>Cons</code> needs an amount of space equal to the size of
an <code>i32</code> plus the size of a <code>List</code>. To figure out how much memory the <code>List</code>
type needs, the compiler looks at the variants, starting with the <code>Cons</code>
variant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type
<code>List</code>, and this process continues infinitely, as shown in Figure 15-1.</p>
<p><img alt="An infinite Cons list: a rectangle labeled 'Cons' split into two smaller rectangles. The first smaller rectangle holds the label 'i32', and the second smaller rectangle holds the label 'Cons' and a smaller version of the outer 'Cons' rectangle. The 'Cons' rectangles continue to hold smaller and smaller versions of themselves until the smallest comfortably sized rectangle holds an infinity symbol, indicating that this repetition goes on forever." src="img/trpl15-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 15-1: An infinite <code>List</code> consisting of infinite
<code>Cons</code> variants</span></p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="using-boxt-to-get-a-recursive-type-with-a-known-size"></a></p>
<h4>Getting a Recursive Type with a Known Size</h4>
<p>Because Rust can’t figure out how much space to allocate for recursively
defined types, the compiler gives an error with this helpful suggestion:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->

<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>In this suggestion, <em>indirection</em> means that instead of storing a value
directly, we should change the data structure to store the value indirectly by
storing a pointer to the value instead.</p>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code>
needs: A pointer’s size doesn’t change based on the amount of data it’s
pointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead
of another <code>List</code> value directly. The <code>Box&lt;T&gt;</code> will point to the next <code>List</code>
value that will be on the heap rather than inside the <code>Cons</code> variant.
Conceptually, we still have a list, created with lists holding other lists, but
this implementation is now more like placing the items next to one another
rather than inside one another.</p>
<p>We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage
of the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile.</p>
<p><Listing number="15-5" file-name="src/main.rs" caption="The definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in order to have a known size"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-05/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>The <code>Cons</code> variant needs the size of an <code>i32</code> plus the space to store the box’s
pointer data. The <code>Nil</code> variant stores no values, so it needs less space on the
stack than the <code>Cons</code> variant. We now know that any <code>List</code> value will take up
the size of an <code>i32</code> plus the size of a box’s pointer data. By using a box,
we’ve broken the infinite, recursive chain, so the compiler can figure out the
size it needs to store a <code>List</code> value. Figure 15-2 shows what the <code>Cons</code>
variant looks like now.</p>
<p><img alt="A rectangle labeled 'Cons' split into two smaller rectangles. The first smaller rectangle holds the label 'i32', and the second smaller rectangle holds the label 'Box' with one inner rectangle that contains the label 'usize', representing the finite size of the box's pointer." src="img/trpl15-02.svg" class="center" /></p>
<p><span class="caption">Figure 15-2: A <code>List</code> that is not infinitely sized,
because <code>Cons</code> holds a <code>Box</code></span></p>
<p>Boxes provide only the indirection and heap allocation; they don’t have any
other special capabilities, like those we’ll see with the other smart pointer
types. They also don’t have the performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. We’ll look at more use cases for boxes
in Chapter 18.</p>
<p>The <code>Box&lt;T&gt;</code> type is a smart pointer because it implements the <code>Deref</code> trait,
which allows <code>Box&lt;T&gt;</code> values to be treated like references. When a <code>Box&lt;T&gt;</code>
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the <code>Drop</code> trait implementation. These two traits will be
even more important to the functionality provided by the other smart pointer
types we’ll discuss in the rest of this chapter. Let’s explore these two traits
in more detail.</p>
</body>
</html>