<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Using Supertraits</title>
</head>
<body>
<h1>Using Supertraits</h1>
<p>Sometimes you might write a trait definition that depends on another trait: For
a type to implement the first trait, you want to require that type to also
implement the second trait. You would do this so that your trait definition can
make use of the associated items of the second trait. The trait your trait
definition is relying on is called a <em>supertrait</em> of your trait.</p>
<p>For example, let’s say we want to make an <code>OutlinePrint</code> trait with an
<code>outline_print</code> method that will print a given value formatted so that it’s
framed in asterisks. That is, given a <code>Point</code> struct that implements the
standard library trait <code>Display</code> to result in <code>(x, y)</code>, when we call
<code>outline_print</code> on a <code>Point</code> instance that has <code>1</code> for <code>x</code> and <code>3</code> for <code>y</code>, it
should print the following:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of the <code>outline_print</code> method, we want to use the
<code>Display</code> trait’s functionality. Therefore, we need to specify that the
<code>OutlinePrint</code> trait will work only for types that also implement <code>Display</code> and
provide the functionality that <code>OutlinePrint</code> needs. We can do that in the
trait definition by specifying <code>OutlinePrint: Display</code>. This technique is
similar to adding a trait bound to the trait. Listing 20-23 shows an
implementation of the <code>OutlinePrint</code> trait.</p>
<p><Listing number="20-23" file-name="src/main.rs" caption="Implementing the <code>OutlinePrint</code> trait that requires the functionality from <code>Display</code>"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-23/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we
can use the <code>to_string</code> function that is automatically implemented for any type
that implements <code>Display</code>. If we tried to use <code>to_string</code> without adding a
colon and specifying the <code>Display</code> trait after the trait name, we’d get an
error saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in
the current scope.</p>
<p>Let’s see what happens when we try to implement <code>OutlinePrint</code> on a type that
doesn’t implement <code>Display</code>, such as the <code>Point</code> struct:</p>
<p><Listing file-name="src/main.rs"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

We get an error saying that `Display` is required but not implemented:

```console
{{#include ../listings/ch20-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
</code></pre>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that
<code>OutlinePrint</code> requires, like so:</p>
<p><Listing file-name="src/main.rs"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>Then, implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile
successfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display
it within an outline of asterisks.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"></a>
<a id="using-the-newtype-pattern-to-implement-external-traits"></a></p>
</body>
</html>