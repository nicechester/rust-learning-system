<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>The Static Lifetime</title>
</head>
<body>
<h1>The Static Lifetime</h1>
<p>One special lifetime we need to discuss is <code>'static</code>, which denotes that the
affected reference <em>can</em> live for the entire duration of the program. All
string literals have the <code>'static</code> lifetime, which we can annotate as follows:</p>
<pre><code class="language-rust">let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
</code></pre>
<p>The text of this string is stored directly in the program’s binary, which is
always available. Therefore, the lifetime of all string literals is <code>'static</code>.</p>
<p>You might see suggestions in error messages to use the <code>'static</code> lifetime. But
before specifying <code>'static</code> as the lifetime for a reference, think about
whether or not the reference you have actually lives the entire lifetime of
your program, and whether you want it to. Most of the time, an error message
suggesting the <code>'static</code> lifetime results from attempting to create a dangling
reference or a mismatch of the available lifetimes. In such cases, the solution
is to fix those problems, not to specify the <code>'static</code> lifetime.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="generic-type-parameters-trait-bounds-and-lifetimes-together"></a></p>
<h2>Generic Type Parameters, Trait Bounds, and Lifetimes</h2>
<p>Let’s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!</p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-11-generics-traits-and-lifetimes/src/main.rs:here}}
</code></pre>
<p>This is the <code>longest</code> function from Listing 10-21 that returns the longer of
two string slices. But now it has an extra parameter named <code>ann</code> of the generic
type <code>T</code>, which can be filled in by any type that implements the <code>Display</code>
trait as specified by the <code>where</code> clause. This extra parameter will be printed
using <code>{}</code>, which is why the <code>Display</code> trait bound is necessary. Because
lifetimes are a type of generic, the declarations of the lifetime parameter
<code>'a</code> and the generic type parameter <code>T</code> go in the same list inside the angle
brackets after the function name.</p>
<h2>Summary</h2>
<p>We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you’re
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, they’ll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code won’t have any dangling references. And all of this
analysis happens at compile time, which doesn’t affect runtime performance!</p>
<p>Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 18 discusses trait objects, which are another way to use
traits. There are also more complex scenarios involving lifetime annotations
that you will only need in very advanced scenarios; for those, you should read
the <a href="../reference/trait-bounds.html">Rust Reference</a>. But next, you’ll learn how to write tests in
Rust so that you can make sure your code is working the way it should.</p>
</body>
</html>