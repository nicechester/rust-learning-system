<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Implementing `Send` and `Sync` Manually Is Unsafe</title>
</head>
<body>
<h1>Implementing `Send` and `Sync` Manually Is Unsafe</h1>
<p>Because types composed entirely of other types that implement the <code>Send</code> and
<code>Sync</code> traits also automatically implement <code>Send</code> and <code>Sync</code>, we don’t have to
implement those traits manually. As marker traits, they don’t even have any
methods to implement. They’re just useful for enforcing invariants related to
concurrency.</p>
<p>Manually implementing these traits involves implementing unsafe Rust code.
We’ll talk about using unsafe Rust code in Chapter 20; for now, the important
information is that building new concurrent types not made up of <code>Send</code> and
<code>Sync</code> parts requires careful thought to uphold the safety guarantees. <a href="../nomicon/index.html">“The
Rustonomicon”</a> has more information about these guarantees and how to
uphold them.</p>
<h2>Summary</h2>
<p>This isn’t the last you’ll see of concurrency in this book: The next chapter
focuses on async programming, and the project in Chapter 21 will use the
concepts in this chapter in a more realistic situation than the smaller
examples discussed here.</p>
<p>As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.</p>
<p>The Rust standard library provides channels for message passing and smart
pointer types, such as <code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won’t end up with data races or invalid references.
Once you get your code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
Go forth and make your programs concurrent, fearlessly!</p>
</body>
</html>