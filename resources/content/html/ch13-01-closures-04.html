<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Moving Captured Values Out of Closures</title>
</head>
<body>
<h1>Moving Captured Values Out of Closures</h1>
<p>Once a closure has captured a reference or captured ownership of a value from
the environment where the closure is defined (thus affecting what, if anything,
is moved <em>into</em> the closure), the code in the body of the closure defines what
happens to the references or values when the closure is evaluated later (thus
affecting what, if anything, is moved <em>out of</em> the closure).</p>
<p>A closure body can do any of the following: Move a captured value out of the
closure, mutate the captured value, neither move nor mutate the value, or
capture nothing from the environment to begin with.</p>
<p>The way a closure captures and handles values from the environment affects
which traits the closure implements, and traits are how functions and structs
can specify what kinds of closures they can use. Closures will automatically
implement one, two, or all three of these <code>Fn</code> traits, in an additive fashion,
depending on how the closure’s body handles the values:</p>
<ul>
<li><code>FnOnce</code> applies to closures that can be called once. All closures implement
  at least this trait because all closures can be called. A closure that moves
  captured values out of its body will only implement <code>FnOnce</code> and none of the
  other <code>Fn</code> traits because it can only be called once.</li>
<li><code>FnMut</code> applies to closures that don’t move captured values out of their body
  but might mutate the captured values. These closures can be called more than
  once.</li>
<li><code>Fn</code> applies to closures that don’t move captured values out of their body
  and don’t mutate captured values, as well as closures that capture nothing
  from their environment. These closures can be called more than once without
  mutating their environment, which is important in cases such as calling a closure multiple times concurrently.</li>
</ul>
<p>Let’s look at the definition of the <code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code> that
we used in Listing 13-1:</p>
<p>```rust,ignore
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</p>
<pre><code>
Recall that `T` is the generic type representing the type of the value in the
`Some` variant of an `Option`. That type `T` is also the return type of the
`unwrap_or_else` function: Code that calls `unwrap_or_else` on an
`Option&lt;String&gt;`, for example, will get a `String`.

Next, notice that the `unwrap_or_else` function has the additional generic type
parameter `F`. The `F` type is the type of the parameter named `f`, which is
the closure we provide when calling `unwrap_or_else`.

The trait bound specified on the generic type `F` is `FnOnce() -&gt; T`, which
means `F` must be able to be called once, take no arguments, and return a `T`.
Using `FnOnce` in the trait bound expresses the constraint that
`unwrap_or_else` will not call `f` more than once. In the body of
`unwrap_or_else`, we can see that if the `Option` is `Some`, `f` won’t be
called. If the `Option` is `None`, `f` will be called once. Because all
closures implement `FnOnce`, `unwrap_or_else` accepts all three kinds of
closures and is as flexible as it can be.

&gt; Note: If what we want to do doesn’t require capturing a value from the
&gt; environment, we can use the name of a function rather than a closure where we
&gt; need something that implements one of the `Fn` traits. For example, on an
&gt; `Option&lt;Vec&lt;T&gt;&gt;` value, we could call `unwrap_or_else(Vec::new)` to get a
&gt; new, empty vector if the value is `None`. The compiler automatically
&gt; implements whichever of the `Fn` traits is applicable for a function
&gt; definition.

Now let’s look at the standard library method `sort_by_key`, defined on slices,
to see how that differs from `unwrap_or_else` and why `sort_by_key` uses
`FnMut` instead of `FnOnce` for the trait bound. The closure gets one argument
in the form of a reference to the current item in the slice being considered,
and it returns a value of type `K` that can be ordered. This function is useful
when you want to sort a slice by a particular attribute of each item. In
Listing 13-7, we have a list of `Rectangle` instances, and we use `sort_by_key`
to order them by their `width` attribute from low to high.

&lt;Listing number=&quot;13-7&quot; file-name=&quot;src/main.rs&quot; caption=&quot;Using `sort_by_key` to order rectangles by width&quot;&gt;

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>This code prints:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}
</code></pre>
<p>The reason <code>sort_by_key</code> is defined to take an <code>FnMut</code> closure is that it calls
the closure multiple times: once for each item in the slice. The closure <code>|r|
r.width</code> doesn’t capture, mutate, or move anything out from its environment, so
it meets the trait bound requirements.</p>
<p>In contrast, Listing 13-8 shows an example of a closure that implements just
the <code>FnOnce</code> trait, because it moves a value out of the environment. The
compiler won’t let us use this closure with <code>sort_by_key</code>.</p>
<p><Listing number="13-8" file-name="src/main.rs" caption="Attempting to use an <code>FnOnce</code> closure with <code>sort_by_key</code>"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}</p>
<pre><code>
&lt;/Listing&gt;

This is a contrived, convoluted way (that doesn’t work) to try to count the
number of times `sort_by_key` calls the closure when sorting `list`. This code
attempts to do this counting by pushing `value`—a `String` from the closure’s
environment—into the `sort_operations` vector. The closure captures `value` and
then moves `value` out of the closure by transferring ownership of `value` to
the `sort_operations` vector. This closure can be called once; trying to call
it a second time wouldn’t work, because `value` would no longer be in the
environment to be pushed into `sort_operations` again! Therefore, this closure
only implements `FnOnce`. When we try to compile this code, we get this error
that `value` can’t be moved out of the closure because the closure must
implement `FnMut`:

```console
{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}
</code></pre>
<p>The error points to the line in the closure body that moves <code>value</code> out of the
environment. To fix this, we need to change the closure body so that it doesn’t
move values out of the environment. Keeping a counter in the environment and
incrementing its value in the closure body is a more straightforward way to
count the number of times the closure is called. The closure in Listing 13-9
works with <code>sort_by_key</code> because it is only capturing a mutable reference to the
<code>num_sort_operations</code> counter and can therefore be called more than once.</p>
<p><Listing number="13-9" file-name="src/main.rs" caption="Using an <code>FnMut</code> closure with <code>sort_by_key</code> is allowed."></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>The <code>Fn</code> traits are important when defining or using functions or types that
make use of closures. In the next section, we’ll discuss iterators. Many
iterator methods take closure arguments, so keep these closure details in mind
as we continue!</p>
</body>
</html>