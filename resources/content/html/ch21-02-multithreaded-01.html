<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Simulating a Slow Request</title>
</head>
<body>
<h1>Simulating a Slow Request</h1>
<p>We’ll look at how a slowly processing request can affect other requests made to
our current server implementation. Listing 21-10 implements handling a request
to <em>/sleep</em> with a simulated slow response that will cause the server to sleep
for five seconds before responding.</p>
<p><Listing number="21-10" file-name="src/main.rs" caption="Simulating a slow request by sleeping for five seconds"></p>
<p><code>rust,no_run
{{#rustdoc_include ../listings/ch21-web-server/listing-21-10/src/main.rs:here}}</code></p>
<p></Listing></p>
<p>We switched from <code>if</code> to <code>match</code> now that we have three cases. We need to
explicitly match on a slice of <code>request_line</code> to pattern-match against the
string literal values; <code>match</code> doesn’t do automatic referencing and
dereferencing, like the equality method does.</p>
<p>The first arm is the same as the <code>if</code> block from Listing 21-9. The second arm
matches a request to <em>/sleep</em>. When that request is received, the server will
sleep for five seconds before rendering the successful HTML page. The third arm
is the same as the <code>else</code> block from Listing 21-9.</p>
<p>You can see how primitive our server is: Real libraries would handle the
recognition of multiple requests in a much less verbose way!</p>
<p>Start the server using <code>cargo run</code>. Then, open two browser windows: one for
<em>http://127.0.0.1:7878</em> and the other for <em>http://127.0.0.1:7878/sleep</em>. If you
enter the <em>/</em> URI a few times, as before, you’ll see it respond quickly. But if
you enter <em>/sleep</em> and then load <em>/</em>, you’ll see that <em>/</em> waits until <code>sleep</code>
has slept for its full five seconds before loading.</p>
<p>There are multiple techniques we could use to avoid requests backing up behind
a slow request, including using async as we did Chapter 17; the one we’ll
implement is a thread pool.</p>
</body>
</html>