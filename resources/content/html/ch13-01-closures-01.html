<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Capturing the Environment</title>
</head>
<body>
<h1>Capturing the Environment</h1>
<p>We’ll first examine how we can use closures to capture values from the
environment they’re defined in for later use. Here’s the scenario: Every so
often, our T-shirt company gives away an exclusive, limited-edition shirt to
someone on our mailing list as a promotion. People on the mailing list can
optionally add their favorite color to their profile. If the person chosen for
a free shirt has their favorite color set, they get that color shirt. If the
person hasn’t specified a favorite color, they get whatever color the company
currently has the most of.</p>
<p>There are many ways to implement this. For this example, we’re going to use an
enum called <code>ShirtColor</code> that has the variants <code>Red</code> and <code>Blue</code> (limiting the
number of colors available for simplicity). We represent the company’s
inventory with an <code>Inventory</code> struct that has a field named <code>shirts</code> that
contains a <code>Vec&lt;ShirtColor&gt;</code> representing the shirt colors currently in stock.
The method <code>giveaway</code> defined on <code>Inventory</code> gets the optional shirt color
preference of the free-shirt winner, and it returns the shirt color the
person will get. This setup is shown in Listing 13-1.</p>
<p><Listing number="13-1" file-name="src/main.rs" caption="Shirt company giveaway situation"></p>
<p>```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}</p>
<pre><code>
&lt;/Listing&gt;

The `store` defined in `main` has two blue shirts and one red shirt remaining
to distribute for this limited-edition promotion. We call the `giveaway` method
for a user with a preference for a red shirt and a user without any preference.

Again, this code could be implemented in many ways, and here, to focus on
closures, we’ve stuck to concepts you’ve already learned, except for the body of
the `giveaway` method that uses a closure. In the `giveaway` method, we get the
user preference as a parameter of type `Option&lt;ShirtColor&gt;` and call the
`unwrap_or_else` method on `user_preference`. The [`unwrap_or_else` method on
`Option&lt;T&gt;`][unwrap-or-else]&lt;!-- ignore --&gt; is defined by the standard library.
It takes one argument: a closure without any arguments that returns a value `T`
(the same type stored in the `Some` variant of the `Option&lt;T&gt;`, in this case
`ShirtColor`). If the `Option&lt;T&gt;` is the `Some` variant, `unwrap_or_else`
returns the value from within the `Some`. If the `Option&lt;T&gt;` is the `None`
variant, `unwrap_or_else` calls the closure and returns the value returned by
the closure.

We specify the closure expression `|| self.most_stocked()` as the argument to
`unwrap_or_else`. This is a closure that takes no parameters itself (if the
closure had parameters, they would appear between the two vertical pipes). The
body of the closure calls `self.most_stocked()`. We’re defining the closure
here, and the implementation of `unwrap_or_else` will evaluate the closure
later if the result is needed.

Running this code prints the following:

```console
{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
</code></pre>
<p>One interesting aspect here is that we’ve passed a closure that calls
<code>self.most_stocked()</code> on the current <code>Inventory</code> instance. The standard library
didn’t need to know anything about the <code>Inventory</code> or <code>ShirtColor</code> types we
defined, or the logic we want to use in this scenario. The closure captures an
immutable reference to the <code>self</code> <code>Inventory</code> instance and passes it with the
code we specify to the <code>unwrap_or_else</code> method. Functions, on the other hand,
are not able to capture their environment in this way.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="closure-type-inference-and-annotation"></a></p>
</body>
</html>