<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Sharing Data</title>
</head>
<body>
<h1>Sharing Data</h1>
<p>Let’s return to our cons list example in Listing 15-5. Recall that we defined
it using <code>Box&lt;T&gt;</code>. This time, we’ll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3.</p>
<p><img alt="A linked list with the label 'a' pointing to three elements. The first element contains the integer 5 and points to the second element. Th
e second element contains the integer 10 and points to the third element. The third element contains the value 'Nil' that signifies the end of the l
ist; it does not point anywhere. A linked list with the label 'b' points to an element that contains the integer 3 and points to the first element o
f list 'a'. A linked list with the label 'c' points to an element that contains the integer 4 and also points to the first element of list 'a' so th
at the tails of lists 'b' and 'c' are both list 'a'." src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Figure 15-3: Two lists, <code>b</code> and <code>c</code>, sharing ownership of
a third list, <code>a</code></span></p>
<p>We’ll create list <code>a</code> that contains <code>5</code> and then <code>10</code>. Then, we’ll make two
more lists: <code>b</code> that starts with <code>3</code> and <code>c</code> that starts with <code>4</code>. Both the <code>b</code>
and <code>c</code> lists will then continue on to the first <code>a</code> list containing <code>5</code> and
<code>10</code>. In other words, both lists will share the first list containing <code>5</code> and
<code>10</code>.</p>
<p>Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T&gt;</code>
won’t work, as shown in Listing 15-17.</p>
<p><Listing number="15-17" file-name="src/main.rs" caption="Demonstrating that we’re not allowed to have two lists using <code>Box&lt;T&gt;</code> that try to share ownership of a third list"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}</p>
<pre><code>
&lt;/Listing&gt;

When we compile this code, we get this error:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
</code></pre>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code>
is moved into <code>b</code> and <code>b</code> owns <code>a</code>. Then, when we try to use <code>a</code> again when
creating <code>c</code>, we’re not allowed to because <code>a</code> has been moved.</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. This is the case for the elements and lists
in Listing 15-17, but not in every scenario.</p>
<p>Instead, we’ll change our definition of <code>List</code> to use <code>Rc&lt;T&gt;</code> in place of
<code>Box&lt;T&gt;</code>, as shown in Listing 15-18. Each <code>Cons</code> variant will now hold a value
and an <code>Rc&lt;T&gt;</code> pointing to a <code>List</code>. When we create <code>b</code>, instead of taking
ownership of <code>a</code>, we’ll clone the <code>Rc&lt;List&gt;</code> that <code>a</code> is holding, thereby
increasing the number of references from one to two and letting <code>a</code> and <code>b</code>
share ownership of the data in that <code>Rc&lt;List&gt;</code>. We’ll also clone <code>a</code> when
creating <code>c</code>, increasing the number of references from two to three. Every time
we call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&lt;List&gt;</code> will
increase, and the data won’t be cleaned up unless there are zero references to
it.</p>
<p><Listing number="15-18" file-name="src/main.rs" caption="A definition of <code>List</code> that uses <code>Rc&lt;T&gt;</code>"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>We need to add a <code>use</code> statement to bring <code>Rc&lt;T&gt;</code> into scope because it’s not
in the prelude. In <code>main</code>, we create the list holding <code>5</code> and <code>10</code> and store it
in a new <code>Rc&lt;List&gt;</code> in <code>a</code>. Then, when we create <code>b</code> and <code>c</code>, we call the
<code>Rc::clone</code> function and pass a reference to the <code>Rc&lt;List&gt;</code> in <code>a</code> as an
argument.</p>
<p>We could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code>, but Rust’s
convention is to use <code>Rc::clone</code> in this case. The implementation of
<code>Rc::clone</code> doesn’t make a deep copy of all the data like most types’
implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using <code>Rc::clone</code> for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
<code>Rc::clone</code>.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="cloning-an-rct-increases-the-reference-count"></a></p>
</body>
</html>