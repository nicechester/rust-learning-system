<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Using `@` Bindings</title>
</head>
<body>
<h1>Using `@` Bindings</h1>
<p>The <em>at</em> operator <code>@</code> lets us create a variable that holds a value at the same
time we’re testing that value for a pattern match. In Listing 19-29, we want to
test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3..=7</code>. We also
want to bind the value to the variable <code>id</code> so that we can use it in the code
associated with the arm.</p>
<p><Listing number="19-29" caption="Using <code>@</code> to bind to a value in a pattern while also testing it"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-29/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id @</code> before
the range <code>3..=7</code>, we’re capturing whatever value matched the range in a
variable named <code>id</code> while also testing that the value matched the range pattern.</p>
<p>In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn’t have a variable that contains the actual value
of the <code>id</code> field. The <code>id</code> field’s value could have been 10, 11, or 12, but
the code that goes with that pattern doesn’t know which it is. The pattern code
isn’t able to use the value from the <code>id</code> field because we haven’t saved the
<code>id</code> value in a variable.</p>
<p>In the last arm, where we’ve specified a variable without a range, we do have
the value available to use in the arm’s code in a variable named <code>id</code>. The
reason is that we’ve used the struct field shorthand syntax. But we haven’t
applied any test to the value in the <code>id</code> field in this arm, as we did with the
first two arms: Any value would match this pattern.</p>
<p>Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<h2>Summary</h2>
<p>Rust’s patterns are very useful in distinguishing between different kinds of
data. When used in <code>match</code> expressions, Rust ensures that your patterns cover
every possible value, or your program won’t compile. Patterns in <code>let</code>
statements and function parameters make those constructs more useful, enabling
the destructuring of values into smaller parts and assigning those parts to
variables. We can create simple or complex patterns to suit our needs.</p>
<p>Next, for the penultimate chapter of the book, we’ll look at some advanced
aspects of a variety of Rust’s features.</p>
</body>
</html>