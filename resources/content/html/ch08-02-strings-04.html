<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Indexing into Strings</title>
</head>
<body>
<h1>Indexing into Strings</h1>
<p>In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if you try to access parts of a <code>String</code> using indexing syntax in Rust, you’ll
get an error. Consider the invalid code in Listing 8-19.</p>
<p><Listing number="8-19" caption="Attempting to use indexing syntax with a <code>String</code>"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

This code will result in the following error:

```console
{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
</code></pre>
<p>The error tells the story: Rust strings don’t support indexing. But why not? To
answer that question, we need to discuss how Rust stores strings in memory.</p>
<h4>Internal Representation</h4>
<p>A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>. Let’s look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:</p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
</code></pre>
<p>In this case, <code>len</code> will be <code>4</code>, which means the vector storing the string
<code>"Hola"</code> is 4 bytes long. Each of these letters takes 1 byte when encoded in
UTF-8. The following line, however, may surprise you (note that this string
begins with the capital Cyrillic letter <em>Ze</em>, not the number 3):</p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
</code></pre>
<p>If you were asked how long the string is, you might say 12. In fact, Rust’s
answer is 24: That’s the number of bytes it takes to encode “Здравствуйте” in
UTF-8, because each Unicode scalar value in that string takes 2 bytes of
storage. Therefore, an index into the string’s bytes will not always correlate
to a valid Unicode scalar value. To demonstrate, consider this invalid Rust
code:</p>
<p>```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &amp;hello[0];</p>
<pre><code>
You already know that `answer` will not be `З`, the first letter. When encoded
in UTF-8, the first byte of `З` is `208` and the second is `151`, so it would
seem that `answer` should in fact be `208`, but `208` is not a valid character
on its own. Returning `208` is likely not what a user would want if they asked
for the first letter of this string; however, that’s the only data that Rust
has at byte index 0. Users generally don’t want the byte value returned, even
if the string contains only Latin letters: If `&amp;&quot;hi&quot;[0]` were valid code that
returned the byte value, it would return `104`, not `h`.

The answer, then, is that to avoid returning an unexpected value and causing
bugs that might not be discovered immediately, Rust doesn’t compile this code
at all and prevents misunderstandings early in the development process.

&lt;!-- Old headings. Do not remove or links may break. --&gt;

&lt;a id=&quot;bytes-and-scalar-values-and-grapheme-clusters-oh-my&quot;&gt;&lt;/a&gt;

#### Bytes, Scalar Values, and Grapheme Clusters

Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rust’s perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call _letters_).

If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is
stored as a vector of `u8` values that looks like this:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>That’s 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rust’s <code>char</code> type is, those
bytes look like this:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>There are six <code>char</code> values here, but the fourth and sixth are not letters:
They’re diacritics that don’t make sense on their own. Finally, if we look at
them as grapheme clusters, we’d get what a person would call the four letters
that make up the Hindi word:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.</p>
<p>A final reason Rust doesn’t allow us to index into a <code>String</code> to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isn’t possible to guarantee that performance with a <code>String</code>,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.</p>
</body>
</html>