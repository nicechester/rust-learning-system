<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Introduction</title>
</head>
<body>
<h1>Introduction</h1>
<h2>Validating References with Lifetimes</h2>
<p>Lifetimes are another kind of generic that we’ve already been using. Rather
than ensuring that a type has the behavior we want, lifetimes ensure that
references are valid as long as we need them to be.</p>
<p>One detail we didn’t discuss in the [“References and
Borrowing”][references-and-borrowing]<!-- ignore --> section in Chapter 4 is
that every reference in Rust has a lifetime, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and inferred,
just like most of the time, types are inferred. We are only required to
annotate types when multiple types are possible. In a similar way, we must
annotate lifetimes when the lifetimes of references could be related in a few
different ways. Rust requires us to annotate the relationships using generic
lifetime parameters to ensure that the actual references used at runtime will
definitely be valid.</p>
<p>Annotating lifetimes is not even a concept most other programming languages
have, so this is going to feel unfamiliar. Although we won’t cover lifetimes in
their entirety in this chapter, we’ll discuss common ways you might encounter
lifetime syntax so that you can get comfortable with the concept.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="preventing-dangling-references-with-lifetimes"></a></p>
</body>
</html>