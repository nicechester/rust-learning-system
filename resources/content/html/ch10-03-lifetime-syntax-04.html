<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Lifetime Annotation Syntax</title>
</head>
<body>
<h1>Lifetime Annotation Syntax</h1>
<p>Lifetime annotations don’t change how long any of the references live. Rather,
they describe the relationships of the lifetimes of multiple references to each
other without affecting the lifetimes. Just as functions can accept any type
when the signature specifies a generic type parameter, functions can accept
references with any lifetime by specifying a generic lifetime parameter.</p>
<p>Lifetime annotations have a slightly unusual syntax: The names of lifetime
parameters must start with an apostrophe (<code>'</code>) and are usually all lowercase
and very short, like generic types. Most people use the name <code>'a</code> for the first
lifetime annotation. We place lifetime parameter annotations after the <code>&amp;</code> of a
reference, using a space to separate the annotation from the reference’s type.</p>
<p>Here are some examples—a reference to an <code>i32</code> without a lifetime parameter, a
reference to an <code>i32</code> that has a lifetime parameter named <code>'a</code>, and a mutable
reference to an <code>i32</code> that also has the lifetime <code>'a</code>:</p>
<p><code>rust,ignore
&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime</code></p>
<p>One lifetime annotation by itself doesn’t have much meaning, because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. Let’s examine how the lifetime annotations
relate to each other in the context of the <code>longest</code> function.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="lifetime-annotations-in-function-signatures"></a></p>
</body>
</html>