<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Removing a `clone` Using an Iterator</title>
</head>
<body>
<h1>Removing a `clone` Using an Iterator</h1>
<p>In Listing 12-6, we added code that took a slice of <code>String</code> values and created
an instance of the <code>Config</code> struct by indexing into the slice and cloning the
values, allowing the <code>Config</code> struct to own those values. In Listing 13-17,
we’ve reproduced the implementation of the <code>Config::build</code> function as it was
in Listing 12-23.</p>
<p><Listing number="13-17" file-name="src/main.rs" caption="Reproduction of the <code>Config::build</code> function from Listing 12-23"></p>
<p>```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-23-reproduced/src/main.rs:ch13}}</p>
<pre><code>
&lt;/Listing&gt;

At the time, we said not to worry about the inefficient `clone` calls because
we would remove them in the future. Well, that time is now!

We needed `clone` here because we have a slice with `String` elements in the
parameter `args`, but the `build` function doesn’t own `args`. To return
ownership of a `Config` instance, we had to clone the values from the `query`
and `file_path` fields of `Config` so that the `Config` instance can own its
values.

With our new knowledge about iterators, we can change the `build` function to
take ownership of an iterator as its argument instead of borrowing a slice.
We’ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
`Config::build` function is doing because the iterator will access the values.

Once `Config::build` takes ownership of the iterator and stops using indexing
operations that borrow, we can move the `String` values from the iterator into
`Config` rather than calling `clone` and making a new allocation.

#### Using the Returned Iterator Directly

Open your I/O project’s _src/main.rs_ file, which should look like this:

&lt;span class=&quot;filename&quot;&gt;Filename: src/main.rs&lt;/span&gt;

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-24-reproduced/src/main.rs:ch13}}
</code></pre>
<p>We’ll first change the start of the <code>main</code> function that we had in Listing
12-24 to the code in Listing 13-18, which this time uses an iterator. This
won’t compile until we update <code>Config::build</code> as well.</p>
<p><Listing number="13-18" file-name="src/main.rs" caption="Passing the return value of <code>env::args</code> to <code>Config::build</code>"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-18/src/main.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

The `env::args` function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to `Config::build`, now
we’re passing ownership of the iterator returned from `env::args` to
`Config::build` directly.

Next, we need to update the definition of `Config::build`. Let’s change the
signature of `Config::build` to look like Listing 13-19. This still won’t
compile, because we need to update the function body.

&lt;Listing number=&quot;13-19&quot; file-name=&quot;src/main.rs&quot; caption=&quot;Updating the signature of `Config::build` to expect an iterator&quot;&gt;

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-19/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>The standard library documentation for the <code>env::args</code> function shows that the
type of the iterator it returns is <code>std::env::Args</code>, and that type implements
the <code>Iterator</code> trait and returns <code>String</code> values.</p>
<p>We’ve updated the signature of the <code>Config::build</code> function so that the
parameter <code>args</code> has a generic type with the trait bounds <code>impl Iterator&lt;Item =
String&gt;</code> instead of <code>&amp;[String]</code>. This usage of the <code>impl Trait</code> syntax we
discussed in the [“Using Traits as Parameters”][impl-trait]<!-- ignore -->
section of Chapter 10 means that <code>args</code> can be any type that implements the
<code>Iterator</code> trait and returns <code>String</code> items.</p>
<p>Because we’re taking ownership of <code>args</code> and we’ll be mutating <code>args</code> by
iterating over it, we can add the <code>mut</code> keyword into the specification of the
<code>args</code> parameter to make it mutable.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="using-iterator-trait-methods-instead-of-indexing"></a></p>
<h4>Using <code>Iterator</code> Trait Methods</h4>
<p>Next, we’ll fix the body of <code>Config::build</code>. Because <code>args</code> implements the
<code>Iterator</code> trait, we know we can call the <code>next</code> method on it! Listing 13-20
updates the code from Listing 12-23 to use the <code>next</code> method.</p>
<p><Listing number="13-20" file-name="src/main.rs" caption="Changing the body of <code>Config::build</code> to use iterator methods"></p>
<p><code>rust,ignore,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-20/src/main.rs:here}}</code></p>
<p></Listing></p>
<p>Remember that the first value in the return value of <code>env::args</code> is the name of
the program. We want to ignore that and get to the next value, so first we call
<code>next</code> and do nothing with the return value. Then, we call <code>next</code> to get the
value we want to put in the <code>query</code> field of <code>Config</code>. If <code>next</code> returns
<code>Some</code>, we use a <code>match</code> to extract the value. If it returns <code>None</code>, it means
not enough arguments were given, and we return early with an <code>Err</code> value. We do
the same thing for the <code>file_path</code> value.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="making-code-clearer-with-iterator-adapters"></a></p>
</body>
</html>