<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Preventing Reference Cycles Using `Weak<T>`</title>
</head>
<body>
<h1>Preventing Reference Cycles Using `Weak<T>`</h1>
<p>So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the
<code>strong_count</code> of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only cleaned
up if its <code>strong_count</code> is 0. You can also create a weak reference to the
value within an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a
reference to the <code>Rc&lt;T&gt;</code>. <em>Strong references</em> are how you can share ownership
of an <code>Rc&lt;T&gt;</code> instance. <em>Weak references</em> don’t express an ownership
relationship, and their count doesn’t affect when an <code>Rc&lt;T&gt;</code> instance is
cleaned up. They won’t cause a reference cycle, because any cycle involving
some weak references will be broken once the strong reference count of values
involved is 0.</p>
<p>When you call <code>Rc::downgrade</code>, you get a smart pointer of type <code>Weak&lt;T&gt;</code>.
Instead of increasing the <code>strong_count</code> in the <code>Rc&lt;T&gt;</code> instance by 1, calling
<code>Rc::downgrade</code> increases the <code>weak_count</code> by 1. The <code>Rc&lt;T&gt;</code> type uses
<code>weak_count</code> to keep track of how many <code>Weak&lt;T&gt;</code> references exist, similar to
<code>strong_count</code>. The difference is the <code>weak_count</code> doesn’t need to be 0 for the
<code>Rc&lt;T&gt;</code> instance to be cleaned up.</p>
<p>Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do
anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to you must make sure the
value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code>
instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. You’ll get a result of <code>Some</code>
if the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the
<code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;Rc&lt;T&gt;&gt;</code>,
Rust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and
there won’t be an invalid pointer.</p>
<p>As an example, rather than using a list whose items know only about the next
item, we’ll create a tree whose items know about their child items <em>and</em> their
parent items.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="creating-a-tree-data-structure-a-node-with-child-nodes"></a></p>
<h4>Creating a Tree Data Structure</h4>
<p>To start, we’ll build a tree with nodes that know about their child nodes.
We’ll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as
references to its child <code>Node</code> values:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:here}}
</code></pre>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with
variables so that we can access each <code>Node</code> in the tree directly. To do this,
we define the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code>. We also want to
modify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in
<code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Next, we’ll use our struct definition and create one <code>Node</code> instance named
<code>leaf</code> with the value <code>3</code> and no children, and another instance named <code>branch</code>
with the value <code>5</code> and <code>leaf</code> as one of its children, as shown in Listing 15-27.</p>
<p><Listing number="15-27" file-name="src/main.rs" caption="Creating a <code>leaf</code> node with no children and a <code>branch</code> node with <code>leaf</code> as one of its children"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:there}}
</code></pre>
<p></Listing></p>
<p>We clone the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> and store that in <code>branch</code>, meaning the
<code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>. We can get from
<code>branch</code> to <code>leaf</code> through <code>branch.children</code>, but there’s no way to get from
<code>leaf</code> to <code>branch</code>. The reason is that <code>leaf</code> has no reference to <code>branch</code> and
doesn’t know they’re related. We want <code>leaf</code> to know that <code>branch</code> is its
parent. We’ll do that next.</p>
<h4>Adding a Reference from a Child to Its Parent</h4>
<p>To make the child node aware of its parent, we need to add a <code>parent</code> field to
our <code>Node</code> struct definition. The trouble is in deciding what the type of
<code>parent</code> should be. We know it can’t contain an <code>Rc&lt;T&gt;</code>, because that would
create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and
<code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code>
values to never be 0.</p>
<p>Thinking about the relationships another way, a parent node should own its
children: If a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: If we drop a child node, the
parent should still exist. This is a case for weak references!</p>
<p>So, instead of <code>Rc&lt;T&gt;</code>, we’ll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>,
specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code>Node</code> struct definition looks
like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:here}}
</code></pre>
<p>A node will be able to refer to its parent node but doesn’t own its parent. In
Listing 15-28, we update <code>main</code> to use this new definition so that the <code>leaf</code>
node will have a way to refer to its parent, <code>branch</code>.</p>
<p><Listing number="15-28" file-name="src/main.rs" caption="A <code>leaf</code> node with a weak reference to its parent node, <code>branch</code>"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:there}}
</code></pre>
<p></Listing></p>
<p>Creating the <code>leaf</code> node looks similar to Listing 15-27 with the exception of
the <code>parent</code> field: <code>leaf</code> starts out without a parent, so we create a new,
empty <code>Weak&lt;Node&gt;</code> reference instance.</p>
<p>At this point, when we try to get a reference to the parent of <code>leaf</code> by using
the <code>upgrade</code> method, we get a <code>None</code> value. We see this in the output from the
first <code>println!</code> statement:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code>
reference in the <code>parent</code> field because <code>branch</code> doesn’t have a parent node. We
still have <code>leaf</code> as one of the children of <code>branch</code>. Once we have the <code>Node</code>
instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code> reference
to its parent. We use the <code>borrow_mut</code> method on the <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in
the <code>parent</code> field of <code>leaf</code>, and then we use the <code>Rc::downgrade</code> function to
create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from the <code>Rc&lt;Node&gt;</code> in <code>branch</code>.</p>
<p>When we print the parent of <code>leaf</code> again, this time we’ll get a <code>Some</code> variant
holding <code>branch</code>: Now <code>leaf</code> can access its parent! When we print <code>leaf</code>, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>The lack of infinite output indicates that this code didn’t create a reference
cycle. We can also tell this by looking at the values we get from calling
<code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>
<h4>Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></h4>
<p>Let’s look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code>
instances change by creating a new inner scope and moving the creation of
<code>branch</code> into that scope. By doing so, we can see what happens when <code>branch</code> is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29.</p>
<p><Listing number="15-29" file-name="src/main.rs" caption="Creating <code>branch</code> in an inner scope and examining strong and weak reference counts"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-29/src/main.rs:here}}
</code></pre>
<p></Listing></p>
<p>After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak
count of 0. In the inner scope, we create <code>branch</code> and associate it with
<code>leaf</code>, at which point when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code>
will have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing
to <code>branch</code> with a <code>Weak&lt;Node&gt;</code>). When we print the counts in <code>leaf</code>, we’ll see
it will have a strong count of 2 because <code>branch</code> now has a clone of the
<code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code> but will still have a weak
count of 0.</p>
<p>When the inner scope ends, <code>branch</code> goes out of scope and the strong count of
the <code>Rc&lt;Node&gt;</code> decreases to 0, so its <code>Node</code> is dropped. The weak count of 1
from <code>leaf.parent</code> has no bearing on whether or not <code>Node</code> is dropped, so we
don’t get any memory leaks!</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we’ll get
<code>None</code> again. At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong
count of 1 and a weak count of 0 because the variable <code>leaf</code> is now the only
reference to the <code>Rc&lt;Node&gt;</code> again.</p>
<p>All of the logic that manages the counts and value dropping is built into
<code>Rc&lt;T&gt;</code> and <code>Weak&lt;T&gt;</code> and their implementations of the <code>Drop</code> trait. By
specifying that the relationship from a child to its parent should be a
<code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, you’re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.</p>
<h2>Summary</h2>
<p>This chapter covered how to use smart pointers to make different guarantees and
trade-offs from those Rust makes by default with regular references. The
<code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The
<code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so
that the data can have multiple owners. The <code>RefCell&lt;T&gt;</code> type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.</p>
<p>Also discussed were the <code>Deref</code> and <code>Drop</code> traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using <code>Weak&lt;T&gt;</code>.</p>
<p>If this chapter has piqued your interest and you want to implement your own
smart pointers, check out <a href="../nomicon/index.html">“The Rustonomicon”</a> for more useful
information.</p>
<p>Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new
smart pointers.</p>
</body>
</html>