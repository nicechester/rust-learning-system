<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Dangling References</title>
</head>
<body>
<h1>Dangling References</h1>
<p>The main aim of lifetimes is to prevent dangling references, which, if they
were allowed to exist, would cause a program to reference data other than the
data it’s intended to reference. Consider the program in Listing 10-16, which
has an outer scope and an inner scope.</p>
<p><Listing number="10-16" caption="An attempt to use a reference whose value has gone out of scope"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/src/main.rs}}</p>
<pre><code>
&lt;/Listing&gt;

&gt; Note: The examples in Listings 10-16, 10-17, and 10-23 declare variables
&gt; without giving them an initial value, so the variable name exists in the outer
&gt; scope. At first glance, this might appear to be in conflict with Rust having
&gt; no null values. However, if we try to use a variable before giving it a value,
&gt; we’ll get a compile-time error, which shows that indeed Rust does not allow
&gt; null values.

The outer scope declares a variable named `r` with no initial value, and the
inner scope declares a variable named `x` with the initial value of `5`. Inside
the inner scope, we attempt to set the value of `r` as a reference to `x`.
Then, the inner scope ends, and we attempt to print the value in `r`. This code
won’t compile, because the value that `r` is referring to has gone out of scope
before we try to use it. Here is the error message:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/output.txt}}
</code></pre>
<p>The error message says that the variable <code>x</code> “does not live long enough.” The
reason is that <code>x</code> will be out of scope when the inner scope ends on line 7.
But <code>r</code> is still valid for the outer scope; because its scope is larger, we say
that it “lives longer.” If Rust allowed this code to work, <code>r</code> would be
referencing memory that was deallocated when <code>x</code> went out of scope, and
anything we tried to do with <code>r</code> wouldn’t work correctly. So, how does Rust
determine that this code is invalid? It uses a borrow checker.</p>
</body>
</html>