<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Capturing References or Moving Ownership</title>
</head>
<body>
<h1>Capturing References or Moving Ownership</h1>
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: borrowing
immutably, borrowing mutably, and taking ownership. The closure will decide
which of these to use based on what the body of the function does with the
captured values.</p>
<p>In Listing 13-4, we define a closure that captures an immutable reference to
the vector named <code>list</code> because it only needs an immutable reference to print
the value.</p>
<p><Listing number="13-4" file-name="src/main.rs" caption="Defining and calling a closure that captures an immutable reference"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>This example also illustrates that a variable can bind to a closure definition,
and we can later call the closure by using the variable name and parentheses as
if the variable name were a function name.</p>
<p>Because we can have multiple immutable references to <code>list</code> at the same time,
<code>list</code> is still accessible from the code before the closure definition, after
the closure definition but before the closure is called, and after the closure
is called. This code compiles, runs, and prints:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}
</code></pre>
<p>Next, in Listing 13-5, we change the closure body so that it adds an element to
the <code>list</code> vector. The closure now captures a mutable reference.</p>
<p><Listing number="13-5" file-name="src/main.rs" caption="Defining and calling a closure that captures a mutable reference"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>This code compiles, runs, and prints:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}
</code></pre>
<p>Note that there’s no longer a <code>println!</code> between the definition and the call of
the <code>borrows_mutably</code> closure: When <code>borrows_mutably</code> is defined, it captures a
mutable reference to <code>list</code>. We don’t use the closure again after the closure
is called, so the mutable borrow ends. Between the closure definition and the
closure call, an immutable borrow to print isn’t allowed, because no other
borrows are allowed when there’s a mutable borrow. Try adding a <code>println!</code>
there to see what error message you get!</p>
<p>If you want to force the closure to take ownership of the values it uses in the
environment even though the body of the closure doesn’t strictly need
ownership, you can use the <code>move</code> keyword before the parameter list.</p>
<p>This technique is mostly useful when passing a closure to a new thread to move
the data so that it’s owned by the new thread. We’ll discuss threads and why
you would want to use them in detail in Chapter 16 when we talk about
concurrency, but for now, let’s briefly explore spawning a new thread using a
closure that needs the <code>move</code> keyword. Listing 13-6 shows Listing 13-4 modified
to print the vector in a new thread rather than in the main thread.</p>
<p><Listing number="13-6" file-name="src/main.rs" caption="Using <code>move</code> to force the closure for the thread to take ownership of <code>list</code>"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>We spawn a new thread, giving the thread a closure to run as an argument. The
closure body prints out the list. In Listing 13-4, the closure only captured
<code>list</code> using an immutable reference because that's the least amount of access
to <code>list</code> needed to print it. In this example, even though the closure body
still only needs an immutable reference, we need to specify that <code>list</code> should
be moved into the closure by putting the <code>move</code> keyword at the beginning of the
closure definition. If the main thread performed more operations before calling
<code>join</code> on the new thread, the new thread might finish before the rest of the
main thread finishes, or the main thread might finish first. If the main thread
maintained ownership of <code>list</code> but ended before the new thread and drops
<code>list</code>, the immutable reference in the thread would be invalid. Therefore, the
compiler requires that <code>list</code> be moved into the closure given to the new thread
so that the reference will be valid. Try removing the <code>move</code> keyword or using
<code>list</code> in the main thread after the closure is defined to see what compiler
errors you get!</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>
<a id="moving-captured-values-out-of-closures-and-the-fn-traits"></a></p>
</body>
</html>