<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Custom Types for Validation</title>
</head>
<body>
<h1>Custom Types for Validation</h1>
<p>Let’s take the idea of using Rust’s type system to ensure that we have a valid
value one step further and look at creating a custom type for validation.
Recall the guessing game in Chapter 2 in which our code asked the user to guess
a number between 1 and 100. We never validated that the user’s guess was
between those numbers before checking it against our secret number; we only
validated that the guess was positive. In this case, the consequences were not
very dire: Our output of “Too high” or “Too low” would still be correct. But it
would be a useful enhancement to guide the user toward valid guesses and have
different behavior when the user guesses a number that’s out of range versus
when the user types, for example, letters instead.</p>
<p>One way to do this would be to parse the guess as an <code>i32</code> instead of only a
<code>u32</code> to allow potentially negative numbers, and then add a check for the
number being in range, like so:</p>
<p><Listing file-name="src/main.rs"></p>
<p>```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

The `if` expression checks whether our value is out of range, tells the user
about the problem, and calls `continue` to start the next iteration of the loop
and ask for another guess. After the `if` expression, we can proceed with the
comparisons between `guess` and the secret number knowing that `guess` is
between 1 and 100.

However, this is not an ideal solution: If it were absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).

Instead, we can make a new type in a dedicated module and put the validations
in a function to create an instance of the type rather than repeating the
validations everywhere. That way, it’s safe for functions to use the new type
in their signatures and confidently use the values they receive. Listing 9-13
shows one way to define a `Guess` type that will only create an instance of
`Guess` if the `new` function receives a value between 1 and 100.

&lt;Listing number=&quot;9-13&quot; caption=&quot;A `Guess` type that will only continue with values between 1 and 100&quot; file-name=&quot;src/guessing_game.rs&quot;&gt;

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-13/src/guessing_game.rs}}
</code></pre>
<p></Listing></p>
<p>Note that this code in <em>src/guessing_game.rs</em> depends on adding a module
declaration <code>mod guessing_game;</code> in <em>src/lib.rs</em> that we haven’t shown here.
Within this new module’s file, we define a struct named <code>Guess</code> that has a
field named <code>value</code> that holds an <code>i32</code>. This is where the number will be
stored.</p>
<p>Then, we implement an associated function named <code>new</code> on <code>Guess</code> that creates
instances of <code>Guess</code> values. The <code>new</code> function is defined to have one
parameter named <code>value</code> of type <code>i32</code> and to return a <code>Guess</code>. The code in the
body of the <code>new</code> function tests <code>value</code> to make sure it’s between 1 and 100.
If <code>value</code> doesn’t pass this test, we make a <code>panic!</code> call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a <code>Guess</code> with a <code>value</code> outside this range would
violate the contract that <code>Guess::new</code> is relying on. The conditions in which
<code>Guess::new</code> might panic should be discussed in its public-facing API
documentation; we’ll cover documentation conventions indicating the possibility
of a <code>panic!</code> in the API documentation that you create in Chapter 14. If
<code>value</code> does pass the test, we create a new <code>Guess</code> with its <code>value</code> field set
to the <code>value</code> parameter and return the <code>Guess</code>.</p>
<p>Next, we implement a method named <code>value</code> that borrows <code>self</code>, doesn’t have any
other parameters, and returns an <code>i32</code>. This kind of method is sometimes called
a <em>getter</em> because its purpose is to get some data from its fields and return
it. This public method is necessary because the <code>value</code> field of the <code>Guess</code>
struct is private. It’s important that the <code>value</code> field be private so that
code using the <code>Guess</code> struct is not allowed to set <code>value</code> directly: Code
outside the <code>guessing_game</code> module <em>must</em> use the <code>Guess::new</code> function to
create an instance of <code>Guess</code>, thereby ensuring that there’s no way for a
<code>Guess</code> to have a <code>value</code> that hasn’t been checked by the conditions in the
<code>Guess::new</code> function.</p>
<p>A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a <code>Guess</code> rather than an
<code>i32</code> and wouldn’t need to do any additional checks in its body.</p>
<h2>Summary</h2>
<p>Rust’s error-handling features are designed to help you write more robust code.
The <code>panic!</code> macro signals that your program is in a state it can’t handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The <code>Result</code> enum uses Rust’s type system to indicate that
operations might fail in a way that your code could recover from. You can use
<code>Result</code> to tell code that calls your code that it needs to handle potential
success or failure as well. Using <code>panic!</code> and <code>Result</code> in the appropriate
situations will make your code more reliable in the face of inevitable problems.</p>
<p>Now that you’ve seen useful ways that the standard library uses generics with
the <code>Option</code> and <code>Result</code> enums, we’ll talk about how generics work and how you
can use them in your code.</p>
</body>
</html>