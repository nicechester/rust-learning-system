<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Executing an Async Function with a Runtime</title>
</head>
<body>
<h1>Executing an Async Function with a Runtime</h1>
<p>To start, we’ll get the title for a single page, shown in Listing 17-3.
Unfortunately, this code doesn’t compile yet.</p>
<p><Listing number="17-3" file-name="src/main.rs" caption="Calling the <code>page_title</code> function from <code>main</code> with a user-supplied argument"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-03/src/main.rs:main}}</p>
<pre><code>
&lt;/Listing&gt;

We follow the same pattern we used to get command line arguments in the
[“Accepting Command Line Arguments”][cli-args]&lt;!-- ignore --&gt; section in
Chapter 12. Then we pass the URL argument to `page_title` and await the result.
Because the value produced by the future is an `Option&lt;String&gt;`, we use a
`match` expression to print different messages to account for whether the page
had a `&lt;title&gt;`.

The only place we can use the `await` keyword is in async functions or blocks,
and Rust won’t let us mark the special `main` function as `async`.

&lt;!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
copy just the compiler error
--&gt;

```text
error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>The reason <code>main</code> can’t be marked <code>async</code> is that async code needs a <em>runtime</em>:
a Rust crate that manages the details of executing asynchronous code. A
program’s <code>main</code> function can <em>initialize</em> a runtime, but it’s not a runtime
<em>itself</em>. (We’ll see more about why this is the case in a bit.) Every Rust
program that executes async code has at least one place where it sets up a
runtime that executes the futures.</p>
<p>Most languages that support async bundle a runtime, but Rust does not. Instead,
there are many different async runtimes available, each of which makes different
tradeoffs suitable to the use case it targets. For example, a high-throughput
web server with many CPU cores and a large amount of RAM has very different
needs than a microcontroller with a single core, a small amount of RAM, and no
heap allocation ability. The crates that provide those runtimes also often
supply async versions of common functionality such as file or network I/O.</p>
<p>Here, and throughout the rest of this chapter, we’ll use the <code>block_on</code>
function from the <code>trpl</code> crate, which takes a future as an argument and blocks
the current thread until this future runs to completion. Behind the scenes,
calling <code>block_on</code> sets up a runtime using the <code>tokio</code> crate that’s used to run
the future passed in (the <code>trpl</code> crate’s <code>block_on</code> behavior is similar to
other runtime crates’ <code>block_on</code> functions). Once the future completes,
<code>block_on</code> returns whatever value the future produced.</p>
<p>We could pass the future returned by <code>page_title</code> directly to <code>block_on</code> and,
once it completed, we could match on the resulting <code>Option&lt;String&gt;</code> as we tried
to do in Listing 17-3. However, for most of the examples in the chapter (and
most async code in the real world), we’ll be doing more than just one async
function call, so instead we’ll pass an <code>async</code> block and explicitly await the
result of the <code>page_title</code> call, as in Listing 17-4.</p>
<p><Listing number="17-4" caption="Awaiting an async block with <code>trpl::block_on</code>" file-name="src/main.rs"></p>
<!-- should_panic,noplayground because mdbook test does not pass args -->

<p>```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch17-async-await/listing-17-04/src/main.rs:run}}</p>
<pre><code>
&lt;/Listing&gt;

When we run this code, we get the behavior we expected initially:

&lt;!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run -- &quot;https://www.rust-lang.org&quot;
# copy the output here
--&gt;

```console
$ cargo run -- &quot;https://www.rust-lang.org&quot;
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>Phew—we finally have some working async code! But before we add the code to
race two sites against each other, let’s briefly turn our attention back to how
futures work.</p>
<p>Each <em>await point</em>—that is, every place where the code uses the <code>await</code>
keyword—represents a place where control is handed back to the runtime. To make
that work, Rust needs to keep track of the state involved in the async block so
that the runtime could kick off some other work and then come back when it’s
ready to try advancing the first one again. This is an invisible state machine,
as if you’d written an enum like this to save the current state at each await
point:</p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch17-async-await/no-listing-state-machine/src/lib.rs:enum}}
</code></pre>
<p>Writing the code to transition between each state by hand would be tedious and
error-prone, however, especially when you need to add more functionality and
more states to the code later. Fortunately, the Rust compiler creates and
manages the state machine data structures for async code automatically. The
normal borrowing and ownership rules around data structures all still apply,
and happily, the compiler also handles checking those for us and provides
useful error messages. We’ll work through a few of those later in the chapter.</p>
<p>Ultimately, something has to execute this state machine, and that something is
a runtime. (This is why you may come across mentions of <em>executors</em> when
looking into runtimes: an executor is the part of a runtime responsible for
executing the async code.)</p>
<p>Now you can see why the compiler stopped us from making <code>main</code> itself an async
function back in Listing 17-3. If <code>main</code> were an async function, something else
would need to manage the state machine for whatever future <code>main</code> returned, but
<code>main</code> is the starting point for the program! Instead, we called the
<code>trpl::block_on</code> function in <code>main</code> to set up a runtime and run the future
returned by the <code>async</code> block until it’s done.</p>
<blockquote>
<p>Note: Some runtimes provide macros so you <em>can</em> write an async <code>main</code>
function. Those macros rewrite <code>async fn main() { ... }</code> to be a normal <code>fn
main</code>, which does the same thing we did by hand in Listing 17-4: call a
function that runs a future to completion the way <code>trpl::block_on</code> does.</p>
</blockquote>
<p>Now let’s put these pieces together and see how we can write concurrent code.</p>
<!-- Old headings. Do not remove or links may break. -->

<p><a id="racing-our-two-urls-against-each-other"></a></p>
</body>
</html>