<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mutable References</title>
</head>
<body>
<h1>Mutable References</h1>
<p>We can fix the code from Listing 4-6 to allow us to modify a borrowed value
with just a few small tweaks that use, instead, a <em>mutable reference</em>:</p>
<p><Listing file-name="src/main.rs"></p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-09-fixes-listing-04-06/src/main.rs}}
</code></pre>
<p></Listing></p>
<p>First, we change <code>s</code> to be <code>mut</code>. Then, we create a mutable reference with
<code>&amp;mut s</code> where we call the <code>change</code> function and update the function signature
to accept a mutable reference with <code>some_string: &amp;mut String</code>. This makes it
very clear that the <code>change</code> function will mutate the value it borrows.</p>
<p>Mutable references have one big restriction: If you have a mutable reference to
a value, you can have no other references to that value. This code that
attempts to create two mutable references to <code>s</code> will fail:</p>
<p><Listing file-name="src/main.rs"></p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/src/main.rs:here}}</p>
<pre><code>
&lt;/Listing&gt;

Here’s the error:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/output.txt}}
</code></pre>
<p>This error says that this code is invalid because we cannot borrow <code>s</code> as
mutable more than once at a time. The first mutable borrow is in <code>r1</code> and must
last until it’s used in the <code>println!</code>, but between the creation of that
mutable reference and its usage, we tried to create another mutable reference
in <code>r2</code> that borrows the same data as <code>r1</code>.</p>
<p>The restriction preventing multiple mutable references to the same data at the
same time allows for mutation but in a very controlled fashion. It’s something
that new Rustaceans struggle with because most languages let you mutate
whenever you’d like. The benefit of having this restriction is that Rust can
prevent data races at compile time. A <em>data race</em> is similar to a race
condition and happens when these three behaviors occur:</p>
<ul>
<li>Two or more pointers access the same data at the same time.</li>
<li>At least one of the pointers is being used to write to the data.</li>
<li>There’s no mechanism being used to synchronize access to the data.</li>
</ul>
<p>Data races cause undefined behavior and can be difficult to diagnose and fix
when you’re trying to track them down at runtime; Rust prevents this problem by
refusing to compile code with data races!</p>
<p>As always, we can use curly brackets to create a new scope, allowing for
multiple mutable references, just not <em>simultaneous</em> ones:</p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-11-muts-in-separate-scopes/src/main.rs:here}}
</code></pre>
<p>Rust enforces a similar rule for combining mutable and immutable references.
This code results in an error:</p>
<p>```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/src/main.rs:here}}</p>
<pre><code>
Here’s the error:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/output.txt}}
</code></pre>
<p>Whew! We <em>also</em> cannot have a mutable reference while we have an immutable one
to the same value.</p>
<p>Users of an immutable reference don’t expect the value to suddenly change out
from under them! However, multiple immutable references are allowed because no
one who is just reading the data has the ability to affect anyone else’s
reading of the data.</p>
<p>Note that a reference’s scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references is in the <code>println!</code>,
before the mutable reference is introduced:</p>
<pre><code class="language-rust">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-13-reference-scope-ends/src/main.rs:here}}
</code></pre>
<p>The scopes of the immutable references <code>r1</code> and <code>r2</code> end after the <code>println!</code>
where they are last used, which is before the mutable reference <code>r3</code> is
created. These scopes don’t overlap, so this code is allowed: The compiler can
tell that the reference is no longer being used at a point before the end of
the scope.</p>
<p>Even though borrowing errors may be frustrating at times, remember that it’s
the Rust compiler pointing out a potential bug early (at compile time rather
than at runtime) and showing you exactly where the problem is. Then, you don’t
have to track down why your data isn’t what you thought it was.</p>
</body>
</html>